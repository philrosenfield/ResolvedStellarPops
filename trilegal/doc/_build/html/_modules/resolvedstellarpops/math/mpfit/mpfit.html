

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>resolvedstellarpops.math.mpfit.mpfit &mdash; ResolvedStellarPops 1.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../../../../',
        VERSION:'1.0',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
    <script type="text/javascript">
        jQuery(function () {
            SphinxRtdTheme.StickyNav.enable();
        });
    </script>
  

  
    <link rel="top" title="ResolvedStellarPops 1.0 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../../../../index.html" class="fa fa-home"> ResolvedStellarPops</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="simple">
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">ResolvedStellarPops</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      
    <li>resolvedstellarpops.math.mpfit.mpfit</li>
      <li class="wy-breadcrumbs-aside">
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  <h1>Source code for resolvedstellarpops.math.mpfit.mpfit</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Perform Levenberg-Marquardt least-squares minimization, based on MINPACK-1.</span>

<span class="sd">                                   AUTHORS</span>
<span class="sd">  The original version of this software, called LMFIT, was written in FORTRAN</span>
<span class="sd">  as part of the MINPACK-1 package by XXX.</span>

<span class="sd">  Craig Markwardt converted the FORTRAN code to IDL.  The information for the</span>
<span class="sd">  IDL version is:</span>
<span class="sd">     Craig B. Markwardt, NASA/GSFC Code 662, Greenbelt, MD 20770</span>
<span class="sd">     craigm@lheamail.gsfc.nasa.gov</span>
<span class="sd">     UPDATED VERSIONs can be found on my WEB PAGE:</span>
<span class="sd">        http://cow.physics.wisc.edu/~craigm/idl/idl.html</span>

<span class="sd">  Mark Rivers created this Python version from Craig&#39;s IDL version.</span>
<span class="sd">    Mark Rivers, University of Chicago</span>
<span class="sd">    Building 434A, Argonne National Laboratory</span>
<span class="sd">    9700 South Cass Avenue, Argonne, IL 60439</span>
<span class="sd">    rivers@cars.uchicago.edu</span>
<span class="sd">    Updated versions can be found at http://cars.uchicago.edu/software</span>

<span class="sd"> Sergey Koposov converted the Mark&#39;s Python version from Numeric to numpy</span>
<span class="sd">    Sergey Koposov, University of Cambridge, Institute of Astronomy,</span>
<span class="sd">    Madingley road, CB3 0HA, Cambridge, UK</span>
<span class="sd">    koposov@ast.cam.ac.uk</span>
<span class="sd">    Updated versions can be found at http://code.google.com/p/astrolibpy/source/browse/trunk/</span>

<span class="sd">                                 DESCRIPTION</span>

<span class="sd"> MPFIT uses the Levenberg-Marquardt technique to solve the</span>
<span class="sd"> least-squares problem.  In its typical use, MPFIT will be used to</span>
<span class="sd"> fit a user-supplied function (the &quot;model&quot;) to user-supplied data</span>
<span class="sd"> points (the &quot;data&quot;) by adjusting a set of parameters.  MPFIT is</span>
<span class="sd"> based upon MINPACK-1 (LMDIF.F) by More&#39; and collaborators.</span>

<span class="sd"> For example, a researcher may think that a set of observed data</span>
<span class="sd"> points is best modelled with a Gaussian curve.  A Gaussian curve is</span>
<span class="sd"> parameterized by its mean, standard deviation and normalization.</span>
<span class="sd"> MPFIT will, within certain constraints, find the set of parameters</span>
<span class="sd"> which best fits the data.  The fit is &quot;best&quot; in the least-squares</span>
<span class="sd"> sense; that is, the sum of the weighted squared differences between</span>
<span class="sd"> the model and data is minimized.</span>

<span class="sd"> The Levenberg-Marquardt technique is a particular strategy for</span>
<span class="sd"> iteratively searching for the best fit.  This particular</span>
<span class="sd"> implementation is drawn from MINPACK-1 (see NETLIB), and is much faster</span>
<span class="sd"> and more accurate than the version provided in the Scientific Python package</span>
<span class="sd"> in Scientific.Functions.LeastSquares.</span>
<span class="sd"> This version allows upper and lower bounding constraints to be placed on each</span>
<span class="sd"> parameter, or the parameter can be held fixed.</span>

<span class="sd"> The user-supplied Python function should return an array of weighted</span>
<span class="sd"> deviations between model and data.  In a typical scientific problem</span>
<span class="sd"> the residuals should be weighted so that each deviate has a</span>
<span class="sd"> gaussian sigma of 1.0.  If X represents values of the independent</span>
<span class="sd"> variable, Y represents a measurement for each value of X, and ERR</span>
<span class="sd"> represents the error in the measurements, then the deviates could</span>
<span class="sd"> be calculated as follows:</span>

<span class="sd">   DEVIATES = (Y - F(X)) / ERR</span>

<span class="sd"> where F is the analytical function representing the model.  You are</span>
<span class="sd"> recommended to use the convenience functions MPFITFUN and</span>
<span class="sd"> MPFITEXPR, which are driver functions that calculate the deviates</span>
<span class="sd"> for you.  If ERR are the 1-sigma uncertainties in Y, then</span>

<span class="sd">   TOTAL( DEVIATES^2 )</span>

<span class="sd"> will be the total chi-squared value.  MPFIT will minimize the</span>
<span class="sd"> chi-square value.  The values of X, Y and ERR are passed through</span>
<span class="sd"> MPFIT to the user-supplied function via the FUNCTKW keyword.</span>

<span class="sd"> Simple constraints can be placed on parameter values by using the</span>
<span class="sd"> PARINFO keyword to MPFIT.  See below for a description of this</span>
<span class="sd"> keyword.</span>

<span class="sd"> MPFIT does not perform more general optimization tasks.  See TNMIN</span>
<span class="sd"> instead.  MPFIT is customized, based on MINPACK-1, to the</span>
<span class="sd"> least-squares minimization problem.</span>


<span class="sd">                               USER FUNCTION</span>

<span class="sd"> The user must define a function which returns the appropriate</span>
<span class="sd"> values as specified above.  The function should return the weighted</span>
<span class="sd"> deviations between the model and the data.  It should also return a status</span>
<span class="sd"> flag and an optional partial derivative array.  For applications which</span>
<span class="sd"> use finite-difference derivatives -- the default -- the user</span>
<span class="sd"> function should be declared in the following way:</span>

<span class="sd">   def myfunct(p, fjac=None, x=None, y=None, err=None)</span>
<span class="sd">    # Parameter values are passed in &quot;p&quot;</span>
<span class="sd">    # If fjac==None then partial derivatives should not be</span>
<span class="sd">    # computed.  It will always be None if MPFIT is called with default</span>
<span class="sd">    # flag.</span>
<span class="sd">    model = F(x, p)</span>
<span class="sd">    # Non-negative status value means MPFIT should continue, negative means</span>
<span class="sd">    # stop the calculation.</span>
<span class="sd">    status = 0</span>
<span class="sd">    return([status, (y-model)/err]</span>

<span class="sd"> See below for applications with analytical derivatives.</span>

<span class="sd"> The keyword parameters X, Y, and ERR in the example above are</span>
<span class="sd"> suggestive but not required.  Any parameters can be passed to</span>
<span class="sd"> MYFUNCT by using the functkw keyword to MPFIT.  Use MPFITFUN and</span>
<span class="sd"> MPFITEXPR if you need ideas on how to do that.  The function *must*</span>
<span class="sd"> accept a parameter list, P.</span>

<span class="sd"> In general there are no restrictions on the number of dimensions in</span>
<span class="sd"> X, Y or ERR.  However the deviates *must* be returned in a</span>
<span class="sd"> one-dimensional Numeric array of type Float.</span>

<span class="sd"> User functions may also indicate a fatal error condition using the</span>
<span class="sd"> status return described above. If status is set to a number between</span>
<span class="sd"> -15 and -1 then MPFIT will stop the calculation and return to the caller.</span>


<span class="sd">                            ANALYTIC DERIVATIVES</span>

<span class="sd"> In the search for the best-fit solution, MPFIT by default</span>
<span class="sd"> calculates derivatives numerically via a finite difference</span>
<span class="sd"> approximation.  The user-supplied function need not calculate the</span>
<span class="sd"> derivatives explicitly.  However, if you desire to compute them</span>
<span class="sd"> analytically, then the AUTODERIVATIVE=0 keyword must be passed to MPFIT.</span>
<span class="sd"> As a practical matter, it is often sufficient and even faster to allow</span>
<span class="sd"> MPFIT to calculate the derivatives numerically, and so</span>
<span class="sd"> AUTODERIVATIVE=0 is not necessary.</span>

<span class="sd"> If AUTODERIVATIVE=0 is used then the user function must check the parameter</span>
<span class="sd"> FJAC, and if FJAC!=None then return the partial derivative array in the</span>
<span class="sd"> return list.</span>
<span class="sd">   def myfunct(p, fjac=None, x=None, y=None, err=None)</span>
<span class="sd">    # Parameter values are passed in &quot;p&quot;</span>
<span class="sd">    # If FJAC!=None then partial derivatives must be comptuer.</span>
<span class="sd">    # FJAC contains an array of len(p), where each entry</span>
<span class="sd">    # is 1 if that parameter is free and 0 if it is fixed.</span>
<span class="sd">    model = F(x, p)</span>
<span class="sd">    Non-negative status value means MPFIT should continue, negative means</span>
<span class="sd">    # stop the calculation.</span>
<span class="sd">    status = 0</span>
<span class="sd">    if (dojac):</span>
<span class="sd">       pderiv = zeros([len(x), len(p)], Float)</span>
<span class="sd">       for j in range(len(p)):</span>
<span class="sd">         pderiv[:,j] = FGRAD(x, p, j)</span>
<span class="sd">    else:</span>
<span class="sd">       pderiv = None</span>
<span class="sd">    return([status, (y-model)/err, pderiv]</span>

<span class="sd"> where FGRAD(x, p, i) is a user function which must compute the</span>
<span class="sd"> derivative of the model with respect to parameter P[i] at X.  When</span>
<span class="sd"> finite differencing is used for computing derivatives (ie, when</span>
<span class="sd"> AUTODERIVATIVE=1), or when MPFIT needs only the errors but not the</span>
<span class="sd"> derivatives the parameter FJAC=None.</span>

<span class="sd"> Derivatives should be returned in the PDERIV array. PDERIV should be an m x</span>
<span class="sd"> n array, where m is the number of data points and n is the number</span>
<span class="sd"> of parameters.  dp[i,j] is the derivative at the ith point with</span>
<span class="sd"> respect to the jth parameter.</span>

<span class="sd"> The derivatives with respect to fixed parameters are ignored; zero</span>
<span class="sd"> is an appropriate value to insert for those derivatives.  Upon</span>
<span class="sd"> input to the user function, FJAC is set to a vector with the same</span>
<span class="sd"> length as P, with a value of 1 for a parameter which is free, and a</span>
<span class="sd"> value of zero for a parameter which is fixed (and hence no</span>
<span class="sd"> derivative needs to be calculated).</span>

<span class="sd"> If the data is higher than one dimensional, then the *last*</span>
<span class="sd"> dimension should be the parameter dimension.  Example: fitting a</span>
<span class="sd"> 50x50 image, &quot;dp&quot; should be 50x50xNPAR.</span>


<span class="sd">           CONSTRAINING PARAMETER VALUES WITH THE PARINFO KEYWORD</span>

<span class="sd"> The behavior of MPFIT can be modified with respect to each</span>
<span class="sd"> parameter to be fitted.  A parameter value can be fixed; simple</span>
<span class="sd"> boundary constraints can be imposed; limitations on the parameter</span>
<span class="sd"> changes can be imposed; properties of the automatic derivative can</span>
<span class="sd"> be modified; and parameters can be tied to one another.</span>

<span class="sd"> These properties are governed by the PARINFO structure, which is</span>
<span class="sd"> passed as a keyword parameter to MPFIT.</span>

<span class="sd"> PARINFO should be a list of dictionaries, one list entry for each parameter.</span>
<span class="sd"> Each parameter is associated with one element of the array, in</span>
<span class="sd"> numerical order.  The dictionary can have the following keys</span>
<span class="sd"> (none are required, keys are case insensitive):</span>

<span class="sd">    &#39;value&#39; - the starting parameter value (but see the START_PARAMS</span>
<span class="sd">             parameter for more information).</span>

<span class="sd">    &#39;fixed&#39; - a boolean value, whether the parameter is to be held</span>
<span class="sd">             fixed or not.  Fixed parameters are not varied by</span>
<span class="sd">             MPFIT, but are passed on to MYFUNCT for evaluation.</span>

<span class="sd">    &#39;limited&#39; - a two-element boolean array.  If the first/second</span>
<span class="sd">               element is set, then the parameter is bounded on the</span>
<span class="sd">               lower/upper side.  A parameter can be bounded on both</span>
<span class="sd">               sides.  Both LIMITED and LIMITS must be given</span>
<span class="sd">               together.</span>

<span class="sd">    &#39;limits&#39; - a two-element float array.  Gives the</span>
<span class="sd">              parameter limits on the lower and upper sides,</span>
<span class="sd">              respectively.  Zero, one or two of these values can be</span>
<span class="sd">              set, depending on the values of LIMITED.  Both LIMITED</span>
<span class="sd">              and LIMITS must be given together.</span>

<span class="sd">    &#39;parname&#39; - a string, giving the name of the parameter.  The</span>
<span class="sd">               fitting code of MPFIT does not use this tag in any</span>
<span class="sd">               way.  However, the default iterfunct will print the</span>
<span class="sd">               parameter name if available.</span>

<span class="sd">    &#39;step&#39; - the step size to be used in calculating the numerical</span>
<span class="sd">            derivatives.  If set to zero, then the step size is</span>
<span class="sd">            computed automatically.  Ignored when AUTODERIVATIVE=0.</span>

<span class="sd">    &#39;mpside&#39; - the sidedness of the finite difference when computing</span>
<span class="sd">              numerical derivatives.  This field can take four</span>
<span class="sd">              values:</span>

<span class="sd">                 0 - one-sided derivative computed automatically</span>
<span class="sd">                 1 - one-sided derivative (f(x+h) - f(x)  )/h</span>
<span class="sd">                -1 - one-sided derivative (f(x)   - f(x-h))/h</span>
<span class="sd">                 2 - two-sided derivative (f(x+h) - f(x-h))/(2*h)</span>

<span class="sd">             Where H is the STEP parameter described above.  The</span>
<span class="sd">             &quot;automatic&quot; one-sided derivative method will chose a</span>
<span class="sd">             direction for the finite difference which does not</span>
<span class="sd">             violate any constraints.  The other methods do not</span>
<span class="sd">             perform this check.  The two-sided method is in</span>
<span class="sd">             principle more precise, but requires twice as many</span>
<span class="sd">             function evaluations.  Default: 0.</span>

<span class="sd">    &#39;mpmaxstep&#39; - the maximum change to be made in the parameter</span>
<span class="sd">                 value.  During the fitting process, the parameter</span>
<span class="sd">                 will never be changed by more than this value in</span>
<span class="sd">                 one iteration.</span>

<span class="sd">                 A value of 0 indicates no maximum.  Default: 0.</span>

<span class="sd">    &#39;tied&#39; - a string expression which &quot;ties&quot; the parameter to other</span>
<span class="sd">            free or fixed parameters.  Any expression involving</span>
<span class="sd">            constants and the parameter array P are permitted.</span>
<span class="sd">            Example: if parameter 2 is always to be twice parameter</span>
<span class="sd">            1 then use the following: parinfo(2).tied = &#39;2 * p(1)&#39;.</span>
<span class="sd">            Since they are totally constrained, tied parameters are</span>
<span class="sd">            considered to be fixed; no errors are computed for them.</span>
<span class="sd">            [ NOTE: the PARNAME can&#39;t be used in expressions. ]</span>

<span class="sd">    &#39;mpprint&#39; - if set to 1, then the default iterfunct will print the</span>
<span class="sd">               parameter value.  If set to 0, the parameter value</span>
<span class="sd">               will not be printed.  This tag can be used to</span>
<span class="sd">               selectively print only a few parameter values out of</span>
<span class="sd">               many.  Default: 1 (all parameters printed)</span>


<span class="sd"> Future modifications to the PARINFO structure, if any, will involve</span>
<span class="sd"> adding dictionary tags beginning with the two letters &quot;MP&quot;.</span>
<span class="sd"> Therefore programmers are urged to avoid using tags starting with</span>
<span class="sd"> the same letters; otherwise they are free to include their own</span>
<span class="sd"> fields within the PARINFO structure, and they will be ignored.</span>

<span class="sd"> PARINFO Example:</span>
<span class="sd"> parinfo = [{&#39;value&#39;:0., &#39;fixed&#39;:0, &#39;limited&#39;:[0,0], &#39;limits&#39;:[0.,0.]}</span>
<span class="sd">                                                for i in range(5)]</span>
<span class="sd"> parinfo[0][&#39;fixed&#39;] = 1</span>
<span class="sd"> parinfo[4][&#39;limited&#39;][0] = 1</span>
<span class="sd"> parinfo[4][&#39;limits&#39;][0]  = 50.</span>
<span class="sd"> values = [5.7, 2.2, 500., 1.5, 2000.]</span>
<span class="sd"> for i in range(5): parinfo[i][&#39;value&#39;]=values[i]</span>

<span class="sd"> A total of 5 parameters, with starting values of 5.7,</span>
<span class="sd"> 2.2, 500, 1.5, and 2000 are given.  The first parameter</span>
<span class="sd"> is fixed at a value of 5.7, and the last parameter is</span>
<span class="sd"> constrained to be above 50.</span>


<span class="sd">                                   EXAMPLE</span>

<span class="sd">   import mpfit</span>
<span class="sd">   import numpy.oldnumeric as Numeric</span>
<span class="sd">   x = arange(100, float)</span>
<span class="sd">   p0 = [5.7, 2.2, 500., 1.5, 2000.]</span>
<span class="sd">   y = ( p[0] + p[1]*[x] + p[2]*[x**2] + p[3]*sqrt(x) +</span>
<span class="sd">         p[4]*log(x))</span>
<span class="sd">   fa = {&#39;x&#39;:x, &#39;y&#39;:y, &#39;err&#39;:err}</span>
<span class="sd">   m = mpfit(&#39;myfunct&#39;, p0, functkw=fa)</span>
<span class="sd">   print &#39;status = &#39;, m.status</span>
<span class="sd">   if (m.status &lt;= 0): print &#39;error message = &#39;, m.errmsg</span>
<span class="sd">   print &#39;parameters = &#39;, m.params</span>

<span class="sd">   Minimizes sum of squares of MYFUNCT.  MYFUNCT is called with the X,</span>
<span class="sd">   Y, and ERR keyword parameters that are given by FUNCTKW.  The</span>
<span class="sd">   results can be obtained from the returned object m.</span>


<span class="sd">                            THEORY OF OPERATION</span>

<span class="sd">   There are many specific strategies for function minimization.  One</span>
<span class="sd">   very popular technique is to use function gradient information to</span>
<span class="sd">   realize the local structure of the function.  Near a local minimum</span>
<span class="sd">   the function value can be taylor expanded about x0 as follows:</span>

<span class="sd">      f(x) = f(x0) + f&#39;(x0) . (x-x0) + (1/2) (x-x0) . f&#39;&#39;(x0) . (x-x0)</span>
<span class="sd">             -----   ---------------   -------------------------------  (1)</span>
<span class="sd">     Order  0th       1st                     2nd</span>

<span class="sd">   Here f&#39;(x) is the gradient vector of f at x, and f&#39;&#39;(x) is the</span>
<span class="sd">   Hessian matrix of second derivatives of f at x.  The vector x is</span>
<span class="sd">   the set of function parameters, not the measured data vector.  One</span>
<span class="sd">   can find the minimum of f, f(xm) using Newton&#39;s method, and</span>
<span class="sd">   arrives at the following linear equation:</span>

<span class="sd">      f&#39;&#39;(x0) . (xm-x0) = - f&#39;(x0)                          (2)</span>

<span class="sd">   If an inverse can be found for f&#39;&#39;(x0) then one can solve for</span>
<span class="sd">   (xm-x0), the step vector from the current position x0 to the new</span>
<span class="sd">   projected minimum.  Here the problem has been linearized (ie, the</span>
<span class="sd">   gradient information is known to first order).  f&#39;&#39;(x0) is</span>
<span class="sd">   symmetric n x n matrix, and should be positive definite.</span>

<span class="sd">   The Levenberg - Marquardt technique is a variation on this theme.</span>
<span class="sd">   It adds an additional diagonal term to the equation which may aid the</span>
<span class="sd">   convergence properties:</span>

<span class="sd">      (f&#39;&#39;(x0) + nu I) . (xm-x0) = -f&#39;(x0)                (2a)</span>

<span class="sd">   where I is the identity matrix.  When nu is large, the overall</span>
<span class="sd">   matrix is diagonally dominant, and the iterations follow steepest</span>
<span class="sd">   descent.  When nu is small, the iterations are quadratically</span>
<span class="sd">   convergent.</span>

<span class="sd">   In principle, if f&#39;&#39;(x0) and f&#39;(x0) are known then xm-x0 can be</span>
<span class="sd">   determined.  However the Hessian matrix is often difficult or</span>
<span class="sd">   impossible to compute.  The gradient f&#39;(x0) may be easier to</span>
<span class="sd">   compute, if even by finite difference techniques.  So-called</span>
<span class="sd">   quasi-Newton techniques attempt to successively estimate f&#39;&#39;(x0)</span>
<span class="sd">   by building up gradient information as the iterations proceed.</span>

<span class="sd">   In the least squares problem there are further simplifications</span>
<span class="sd">   which assist in solving eqn (2).  The function to be minimized is</span>
<span class="sd">   a sum of squares:</span>

<span class="sd">       f = Sum(hi^2)                                         (3)</span>

<span class="sd">   where hi is the ith residual out of m residuals as described</span>
<span class="sd">   above.  This can be substituted back into eqn (2) after computing</span>
<span class="sd">   the derivatives:</span>

<span class="sd">       f&#39;  = 2 Sum(hi  hi&#39;)</span>
<span class="sd">       f&#39;&#39; = 2 Sum(hi&#39; hj&#39;) + 2 Sum(hi hi&#39;&#39;)                (4)</span>

<span class="sd">   If one assumes that the parameters are already close enough to a</span>
<span class="sd">   minimum, then one typically finds that the second term in f&#39;&#39; is</span>
<span class="sd">   negligible [or, in any case, is too difficult to compute].  Thus,</span>
<span class="sd">   equation (2) can be solved, at least approximately, using only</span>
<span class="sd">   gradient information.</span>

<span class="sd">   In matrix notation, the combination of eqns (2) and (4) becomes:</span>

<span class="sd">        hT&#39; . h&#39; . dx = - hT&#39; . h                         (5)</span>

<span class="sd">   Where h is the residual vector (length m), hT is its transpose, h&#39;</span>
<span class="sd">   is the Jacobian matrix (dimensions n x m), and dx is (xm-x0).  The</span>
<span class="sd">   user function supplies the residual vector h, and in some cases h&#39;</span>
<span class="sd">   when it is not found by finite differences (see MPFIT_FDJAC2,</span>
<span class="sd">   which finds h and hT&#39;).  Even if dx is not the best absolute step</span>
<span class="sd">   to take, it does provide a good estimate of the best *direction*,</span>
<span class="sd">   so often a line minimization will occur along the dx vector</span>
<span class="sd">   direction.</span>

<span class="sd">   The method of solution employed by MINPACK is to form the Q . R</span>
<span class="sd">   factorization of h&#39;, where Q is an orthogonal matrix such that QT .</span>
<span class="sd">   Q = I, and R is upper right triangular.  Using h&#39; = Q . R and the</span>
<span class="sd">   ortogonality of Q, eqn (5) becomes</span>

<span class="sd">        (RT . QT) . (Q . R) . dx = - (RT . QT) . h</span>
<span class="sd">                     RT . R . dx = - RT . QT . h         (6)</span>
<span class="sd">                          R . dx = - QT . h</span>

<span class="sd">   where the last statement follows because R is upper triangular.</span>
<span class="sd">   Here, R, QT and h are known so this is a matter of solving for dx.</span>
<span class="sd">   The routine MPFIT_QRFAC provides the QR factorization of h, with</span>
<span class="sd">   pivoting, and MPFIT_QRSOLV provides the solution for dx.</span>


<span class="sd">                                 REFERENCES</span>

<span class="sd">   MINPACK-1, Jorge More&#39;, available from netlib (www.netlib.org).</span>
<span class="sd">   &quot;Optimization Software Guide,&quot; Jorge More&#39; and Stephen Wright,</span>
<span class="sd">     SIAM, *Frontiers in Applied Mathematics*, Number 14.</span>
<span class="sd">   More&#39;, Jorge J., &quot;The Levenberg-Marquardt Algorithm:</span>
<span class="sd">     Implementation and Theory,&quot; in *Numerical Analysis*, ed. Watson,</span>
<span class="sd">     G. A., Lecture Notes in Mathematics 630, Springer-Verlag, 1977.</span>


<span class="sd">                           MODIFICATION HISTORY</span>

<span class="sd">   Translated from MINPACK-1 in FORTRAN, Apr-Jul 1998, CM</span>
<span class="sd"> Copyright (C) 1997-2002, Craig Markwardt</span>
<span class="sd"> This software is provided as is without any warranty whatsoever.</span>
<span class="sd"> Permission to use, copy, modify, and distribute modified or</span>
<span class="sd"> unmodified copies is granted, provided this copyright and disclaimer</span>
<span class="sd"> are included unchanged.</span>

<span class="sd">   Translated from MPFIT (Craig Markwardt&#39;s IDL package) to Python,</span>
<span class="sd">   August, 2002.  Mark Rivers</span>
<span class="sd">   Converted from Numeric to numpy (Sergey Koposov, July 2008)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="c">#import types</span>
<span class="kn">import</span> <span class="nn">scipy.lib.blas</span>

<span class="c">#    Original FORTRAN documentation</span>
<span class="c">#    **********</span>
<span class="c">#</span>
<span class="c">#    subroutine lmdif</span>
<span class="c">#</span>
<span class="c">#    the purpose of lmdif is to minimize the sum of the squares of</span>
<span class="c">#    m nonlinear functions in n variables by a modification of</span>
<span class="c">#    the levenberg-marquardt algorithm. the user must provide a</span>
<span class="c">#    subroutine which calculates the functions. the jacobian is</span>
<span class="c">#    then calculated by a forward-difference approximation.</span>
<span class="c">#</span>
<span class="c">#    the subroutine statement is</span>
<span class="c">#</span>
<span class="c">#      subroutine lmdif(fcn,m,n,x,fvec,ftol,xtol,gtol,maxfev,epsfcn,</span>
<span class="c">#                       diag,mode,factor,nprint,info,nfev,fjac,</span>
<span class="c">#                       ldfjac,ipvt,qtf,wa1,wa2,wa3,wa4)</span>
<span class="c">#</span>
<span class="c">#    where</span>
<span class="c">#</span>
<span class="c">#      fcn is the name of the user-supplied subroutine which</span>
<span class="c">#        calculates the functions. fcn must be declared</span>
<span class="c">#        in an external statement in the user calling</span>
<span class="c">#        program, and should be written as follows.</span>
<span class="c">#</span>
<span class="c">#        subroutine fcn(m,n,x,fvec,iflag)</span>
<span class="c">#        integer m,n,iflag</span>
<span class="c">#        double precision x(n),fvec(m)</span>
<span class="c">#        ----------</span>
<span class="c">#        calculate the functions at x and</span>
<span class="c">#        return this vector in fvec.</span>
<span class="c">#        ----------</span>
<span class="c">#        return</span>
<span class="c">#        end</span>
<span class="c">#</span>
<span class="c">#        the value of iflag should not be changed by fcn unless</span>
<span class="c">#        the user wants to terminate execution of lmdif.</span>
<span class="c">#        in this case set iflag to a negative integer.</span>
<span class="c">#</span>
<span class="c">#      m is a positive integer input variable set to the number</span>
<span class="c">#        of functions.</span>
<span class="c">#</span>
<span class="c">#      n is a positive integer input variable set to the number</span>
<span class="c">#        of variables. n must not exceed m.</span>
<span class="c">#</span>
<span class="c">#      x is an array of length n. on input x must contain</span>
<span class="c">#        an initial estimate of the solution vector. on output x</span>
<span class="c">#        contains the final estimate of the solution vector.</span>
<span class="c">#</span>
<span class="c">#      fvec is an output array of length m which contains</span>
<span class="c">#        the functions evaluated at the output x.</span>
<span class="c">#</span>
<span class="c">#      ftol is a nonnegative input variable. termination</span>
<span class="c">#        occurs when both the actual and predicted relative</span>
<span class="c">#        reductions in the sum of squares are at most ftol.</span>
<span class="c">#        therefore, ftol measures the relative error desired</span>
<span class="c">#        in the sum of squares.</span>
<span class="c">#</span>
<span class="c">#      xtol is a nonnegative input variable. termination</span>
<span class="c">#        occurs when the relative error between two consecutive</span>
<span class="c">#        iterates is at most xtol. therefore, xtol measures the</span>
<span class="c">#        relative error desired in the approximate solution.</span>
<span class="c">#</span>
<span class="c">#      gtol is a nonnegative input variable. termination</span>
<span class="c">#        occurs when the cosine of the angle between fvec and</span>
<span class="c">#        any column of the jacobian is at most gtol in absolute</span>
<span class="c">#        value. therefore, gtol measures the orthogonality</span>
<span class="c">#        desired between the function vector and the columns</span>
<span class="c">#        of the jacobian.</span>
<span class="c">#</span>
<span class="c">#      maxfev is a positive integer input variable. termination</span>
<span class="c">#        occurs when the number of calls to fcn is at least</span>
<span class="c">#        maxfev by the end of an iteration.</span>
<span class="c">#</span>
<span class="c">#      epsfcn is an input variable used in determining a suitable</span>
<span class="c">#        step length for the forward-difference approximation. this</span>
<span class="c">#        approximation assumes that the relative errors in the</span>
<span class="c">#        functions are of the order of epsfcn. if epsfcn is less</span>
<span class="c">#        than the machine precision, it is assumed that the relative</span>
<span class="c">#        errors in the functions are of the order of the machine</span>
<span class="c">#        precision.</span>
<span class="c">#</span>
<span class="c">#      diag is an array of length n. if mode = 1 (see</span>
<span class="c">#        below), diag is internally set. if mode = 2, diag</span>
<span class="c">#        must contain positive entries that serve as</span>
<span class="c">#        multiplicative scale factors for the variables.</span>
<span class="c">#</span>
<span class="c">#      mode is an integer input variable. if mode = 1, the</span>
<span class="c">#        variables will be scaled internally. if mode = 2,</span>
<span class="c">#        the scaling is specified by the input diag. other</span>
<span class="c">#        values of mode are equivalent to mode = 1.</span>
<span class="c">#</span>
<span class="c">#      factor is a positive input variable used in determining the</span>
<span class="c">#        initial step bound. this bound is set to the product of</span>
<span class="c">#        factor and the euclidean norm of diag*x if nonzero, or else</span>
<span class="c">#        to factor itself. in most cases factor should lie in the</span>
<span class="c">#        interval (.1,100.). 100. is a generally recommended value.</span>
<span class="c">#</span>
<span class="c">#      nprint is an integer input variable that enables controlled</span>
<span class="c">#        printing of iterates if it is positive. in this case,</span>
<span class="c">#        fcn is called with iflag = 0 at the beginning of the first</span>
<span class="c">#        iteration and every nprint iterations thereafter and</span>
<span class="c">#        immediately prior to return, with x and fvec available</span>
<span class="c">#        for printing. if nprint is not positive, no special calls</span>
<span class="c">#        of fcn with iflag = 0 are made.</span>
<span class="c">#</span>
<span class="c">#      info is an integer output variable. if the user has</span>
<span class="c">#        terminated execution, info is set to the (negative)</span>
<span class="c">#        value of iflag. see description of fcn. otherwise,</span>
<span class="c">#        info is set as follows.</span>
<span class="c">#</span>
<span class="c">#        info = 0  improper input parameters.</span>
<span class="c">#</span>
<span class="c">#        info = 1  both actual and predicted relative reductions</span>
<span class="c">#                  in the sum of squares are at most ftol.</span>
<span class="c">#</span>
<span class="c">#        info = 2  relative error between two consecutive iterates</span>
<span class="c">#                  is at most xtol.</span>
<span class="c">#</span>
<span class="c">#        info = 3  conditions for info = 1 and info = 2 both hold.</span>
<span class="c">#</span>
<span class="c">#        info = 4  the cosine of the angle between fvec and any</span>
<span class="c">#                  column of the jacobian is at most gtol in</span>
<span class="c">#                  absolute value.</span>
<span class="c">#</span>
<span class="c">#        info = 5  number of calls to fcn has reached or</span>
<span class="c">#                  exceeded maxfev.</span>
<span class="c">#</span>
<span class="c">#        info = 6  ftol is too small. no further reduction in</span>
<span class="c">#                  the sum of squares is possible.</span>
<span class="c">#</span>
<span class="c">#        info = 7  xtol is too small. no further improvement in</span>
<span class="c">#                  the approximate solution x is possible.</span>
<span class="c">#</span>
<span class="c">#        info = 8  gtol is too small. fvec is orthogonal to the</span>
<span class="c">#                  columns of the jacobian to machine precision.</span>
<span class="c">#</span>
<span class="c">#      nfev is an integer output variable set to the number of</span>
<span class="c">#        calls to fcn.</span>
<span class="c">#</span>
<span class="c">#      fjac is an output m by n array. the upper n by n submatrix</span>
<span class="c">#        of fjac contains an upper triangular matrix r with</span>
<span class="c">#        diagonal elements of nonincreasing magnitude such that</span>
<span class="c">#</span>
<span class="c">#               t    t         t</span>
<span class="c">#              p *(jac *jac)*p = r *r,</span>
<span class="c">#</span>
<span class="c">#        where p is a permutation matrix and jac is the final</span>
<span class="c">#        calculated jacobian. column j of p is column ipvt(j)</span>
<span class="c">#        (see below) of the identity matrix. the lower trapezoidal</span>
<span class="c">#        part of fjac contains information generated during</span>
<span class="c">#        the computation of r.</span>
<span class="c">#</span>
<span class="c">#      ldfjac is a positive integer input variable not less than m</span>
<span class="c">#        which specifies the leading dimension of the array fjac.</span>
<span class="c">#</span>
<span class="c">#      ipvt is an integer output array of length n. ipvt</span>
<span class="c">#        defines a permutation matrix p such that jac*p = q*r,</span>
<span class="c">#        where jac is the final calculated jacobian, q is</span>
<span class="c">#        orthogonal (not stored), and r is upper triangular</span>
<span class="c">#        with diagonal elements of nonincreasing magnitude.</span>
<span class="c">#        column j of p is column ipvt(j) of the identity matrix.</span>
<span class="c">#</span>
<span class="c">#      qtf is an output array of length n which contains</span>
<span class="c">#        the first n elements of the vector (q transpose)*fvec.</span>
<span class="c">#</span>
<span class="c">#      wa1, wa2, and wa3 are work arrays of length n.</span>
<span class="c">#</span>
<span class="c">#      wa4 is a work array of length m.</span>
<span class="c">#</span>
<span class="c">#    subprograms called</span>
<span class="c">#</span>
<span class="c">#      user-supplied ...... fcn</span>
<span class="c">#</span>
<span class="c">#      minpack-supplied ... dpmpar,enorm,fdjac2,,qrfac</span>
<span class="c">#</span>
<span class="c">#      fortran-supplied ... dabs,dmax1,dmin1,dsqrt,mod</span>
<span class="c">#</span>
<span class="c">#    argonne national laboratory. minpack project. march 1980.</span>
<span class="c">#    burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
<span class="c">#</span>
<span class="c">#    **********</span>


<div class="viewcode-block" id="mpfit"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit">[docs]</a><span class="k">class</span> <span class="nc">mpfit</span><span class="p">:</span>

    <span class="n">blas_enorm32</span><span class="p">,</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">blas</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span>
        <span class="p">[</span><span class="s">&#39;nrm2&#39;</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
    <span class="n">blas_enorm64</span><span class="p">,</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">blas</span><span class="o">.</span><span class="n">get_blas_funcs</span><span class="p">(</span>
        <span class="p">[</span><span class="s">&#39;nrm2&#39;</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">xall</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">functkw</span><span class="o">=</span><span class="p">{},</span> <span class="n">parinfo</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">ftol</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">,</span> <span class="n">gtol</span><span class="o">=</span><span class="mf">1.e-10</span><span class="p">,</span>
                 <span class="n">damp</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">nprint</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">iterfunct</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="n">iterkw</span><span class="o">=</span><span class="p">{},</span> <span class="n">nocovar</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">rescale</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">autoderivative</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                 <span class="n">diag</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">epsfcn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Inputs:</span>
<span class="sd">    fcn:</span>
<span class="sd">       The function to be minimized.  The function should return the weighted</span>
<span class="sd">       deviations between the model and the data, as described above.</span>

<span class="sd">    xall:</span>
<span class="sd">       An array of starting values for each of the parameters of the model.</span>
<span class="sd">       The number of parameters should be fewer than the number of measurements.</span>

<span class="sd">       This parameter is optional if the parinfo keyword is used (but see</span>
<span class="sd">       parinfo).  The parinfo keyword provides a mechanism to fix or constrain</span>
<span class="sd">       individual parameters.</span>

<span class="sd">  Keywords:</span>

<span class="sd">     autoderivative:</span>
<span class="sd">        If this is set, derivatives of the function will be computed</span>
<span class="sd">        automatically via a finite differencing procedure.  If not set, then</span>
<span class="sd">        fcn must provide the (analytical) derivatives.</span>
<span class="sd">           Default: set (=1)</span>
<span class="sd">           NOTE: to supply your own analytical derivatives,</span>
<span class="sd">                 explicitly pass autoderivative=0</span>

<span class="sd">     ftol:</span>
<span class="sd">        A nonnegative input variable. Termination occurs when both the actual</span>
<span class="sd">        and predicted relative reductions in the sum of squares are at most</span>
<span class="sd">        ftol (and status is accordingly set to 1 or 3).  Therefore, ftol</span>
<span class="sd">        measures the relative error desired in the sum of squares.</span>
<span class="sd">           Default: 1E-10</span>

<span class="sd">     functkw:</span>
<span class="sd">        A dictionary which contains the parameters to be passed to the</span>
<span class="sd">        user-supplied function specified by fcn via the standard Python</span>
<span class="sd">        keyword dictionary mechanism.  This is the way you can pass additional</span>
<span class="sd">        data to your user-supplied function without using global variables.</span>

<span class="sd">        Consider the following example:</span>
<span class="sd">           if functkw = {&#39;xval&#39;:[1.,2.,3.], &#39;yval&#39;:[1.,4.,9.],</span>
<span class="sd">                         &#39;errval&#39;:[1.,1.,1.] }</span>
<span class="sd">        then the user supplied function should be declared like this:</span>
<span class="sd">           def myfunct(p, fjac=None, xval=None, yval=None, errval=None):</span>

<span class="sd">        Default: {}   No extra parameters are passed to the user-supplied</span>
<span class="sd">                      function.</span>

<span class="sd">     gtol:</span>
<span class="sd">        A nonnegative input variable. Termination occurs when the cosine of</span>
<span class="sd">        the angle between fvec and any column of the jacobian is at most gtol</span>
<span class="sd">        in absolute value (and status is accordingly set to 4). Therefore,</span>
<span class="sd">        gtol measures the orthogonality desired between the function vector</span>
<span class="sd">        and the columns of the jacobian.</span>
<span class="sd">           Default: 1e-10</span>

<span class="sd">     iterkw:</span>
<span class="sd">        The keyword arguments to be passed to iterfunct via the dictionary</span>
<span class="sd">        keyword mechanism.  This should be a dictionary and is similar in</span>
<span class="sd">        operation to FUNCTKW.</span>
<span class="sd">           Default: {}  No arguments are passed.</span>

<span class="sd">     iterfunct:</span>
<span class="sd">        The name of a function to be called upon each NPRINT iteration of the</span>
<span class="sd">        MPFIT routine.  It should be declared in the following way:</span>
<span class="sd">           def iterfunct(myfunct, p, iter, fnorm, functkw=None,</span>
<span class="sd">                         parinfo=None, quiet=0, dof=None, [iterkw keywords here])</span>
<span class="sd">           # perform custom iteration update</span>

<span class="sd">        iterfunct must accept all three keyword parameters (FUNCTKW, PARINFO</span>
<span class="sd">        and QUIET).</span>

<span class="sd">        myfunct:  The user-supplied function to be minimized,</span>
<span class="sd">        p:      The current set of model parameters</span>
<span class="sd">        iter:    The iteration number</span>
<span class="sd">        functkw:  The arguments to be passed to myfunct.</span>
<span class="sd">        fnorm:  The chi-squared value.</span>
<span class="sd">        quiet:  Set when no textual output should be printed.</span>
<span class="sd">        dof:      The number of degrees of freedom, normally the number of points</span>
<span class="sd">                  less the number of free parameters.</span>
<span class="sd">        See below for documentation of parinfo.</span>

<span class="sd">        In implementation, iterfunct can perform updates to the terminal or</span>
<span class="sd">        graphical user interface, to provide feedback while the fit proceeds.</span>
<span class="sd">        If the fit is to be stopped for any reason, then iterfunct should return a</span>
<span class="sd">        a status value between -15 and -1.  Otherwise it should return None</span>
<span class="sd">        (e.g. no return statement) or 0.</span>
<span class="sd">        In principle, iterfunct should probably not modify the parameter values,</span>
<span class="sd">        because it may interfere with the algorithm&#39;s stability.  In practice it</span>
<span class="sd">        is allowed.</span>

<span class="sd">        Default: an internal routine is used to print the parameter values.</span>

<span class="sd">        Set iterfunct=None if there is no user-defined routine and you don&#39;t</span>
<span class="sd">        want the internal default routine be called.</span>

<span class="sd">     maxiter:</span>
<span class="sd">        The maximum number of iterations to perform.  If the number is exceeded,</span>
<span class="sd">        then the status value is set to 5 and MPFIT returns.</span>
<span class="sd">        Default: 200 iterations</span>

<span class="sd">     nocovar:</span>
<span class="sd">        Set this keyword to prevent the calculation of the covariance matrix</span>
<span class="sd">        before returning (see COVAR)</span>
<span class="sd">        Default: clear (=0)  The covariance matrix is returned</span>

<span class="sd">     nprint:</span>
<span class="sd">        The frequency with which iterfunct is called.  A value of 1 indicates</span>
<span class="sd">        that iterfunct is called with every iteration, while 2 indicates every</span>
<span class="sd">        other iteration, etc.  Note that several Levenberg-Marquardt attempts</span>
<span class="sd">        can be made in a single iteration.</span>
<span class="sd">        Default value: 1</span>

<span class="sd">     parinfo</span>
<span class="sd">        Provides a mechanism for more sophisticated constraints to be placed on</span>
<span class="sd">        parameter values.  When parinfo is not passed, then it is assumed that</span>
<span class="sd">        all parameters are free and unconstrained.  Values in parinfo are never</span>
<span class="sd">        modified during a call to MPFIT.</span>

<span class="sd">        See description above for the structure of PARINFO.</span>

<span class="sd">        Default value: None  All parameters are free and unconstrained.</span>

<span class="sd">     quiet:</span>
<span class="sd">        Set this keyword when no textual output should be printed by MPFIT</span>

<span class="sd">     damp:</span>
<span class="sd">        A scalar number, indicating the cut-off value of residuals where</span>
<span class="sd">        &quot;damping&quot; will occur.  Residuals with magnitudes greater than this</span>
<span class="sd">        number will be replaced by their hyperbolic tangent.  This partially</span>
<span class="sd">        mitigates the so-called large residual problem inherent in</span>
<span class="sd">        least-squares solvers (as for the test problem CURVI,</span>
<span class="sd">        http://www.maxthis.com/curviex.htm).</span>
<span class="sd">        A value of 0 indicates no damping.</span>
<span class="sd">           Default: 0</span>

<span class="sd">        Note: DAMP doesn&#39;t work with autoderivative=0</span>

<span class="sd">     xtol:</span>
<span class="sd">        A nonnegative input variable. Termination occurs when the relative error</span>
<span class="sd">        between two consecutive iterates is at most xtol (and status is</span>
<span class="sd">        accordingly set to 2 or 3).  Therefore, xtol measures the relative error</span>
<span class="sd">        desired in the approximate solution.</span>
<span class="sd">        Default: 1E-10</span>

<span class="sd">   Outputs:</span>

<span class="sd">     Returns an object of type mpfit.  The results are attributes of this class,</span>
<span class="sd">     e.g. mpfit.status, mpfit.errmsg, mpfit.params, npfit.niter, mpfit.covar.</span>

<span class="sd">     .status</span>
<span class="sd">        An integer status code is returned.  All values greater than zero can</span>
<span class="sd">        represent success (however .status == 5 may indicate failure to</span>
<span class="sd">        converge). It can have one of the following values:</span>

<span class="sd">        -16</span>
<span class="sd">           A parameter or function value has become infinite or an undefined</span>
<span class="sd">           number.  This is usually a consequence of numerical overflow in the</span>
<span class="sd">           user&#39;s model function, which must be avoided.</span>

<span class="sd">        -15 to -1</span>
<span class="sd">           These are error codes that either MYFUNCT or iterfunct may return to</span>
<span class="sd">           terminate the fitting process.  Values from -15 to -1 are reserved</span>
<span class="sd">           for the user functions and will not clash with MPFIT.</span>

<span class="sd">        0  Improper input parameters.</span>

<span class="sd">        1  Both actual and predicted relative reductions in the sum of squares</span>
<span class="sd">           are at most ftol.</span>

<span class="sd">        2  Relative error between two consecutive iterates is at most xtol</span>

<span class="sd">        3  Conditions for status = 1 and status = 2 both hold.</span>

<span class="sd">        4  The cosine of the angle between fvec and any column of the jacobian</span>
<span class="sd">           is at most gtol in absolute value.</span>

<span class="sd">        5  The maximum number of iterations has been reached.</span>

<span class="sd">        6  ftol is too small. No further reduction in the sum of squares is</span>
<span class="sd">           possible.</span>

<span class="sd">        7  xtol is too small. No further improvement in the approximate solution</span>
<span class="sd">           x is possible.</span>

<span class="sd">        8  gtol is too small. fvec is orthogonal to the columns of the jacobian</span>
<span class="sd">           to machine precision.</span>

<span class="sd">     .fnorm</span>
<span class="sd">        The value of the summed squared residuals for the returned parameter</span>
<span class="sd">        values.</span>

<span class="sd">     .covar</span>
<span class="sd">        The covariance matrix for the set of parameters returned by MPFIT.</span>
<span class="sd">        The matrix is NxN where N is the number of  parameters.  The square root</span>
<span class="sd">        of the diagonal elements gives the formal 1-sigma statistical errors on</span>
<span class="sd">        the parameters if errors were treated &quot;properly&quot; in fcn.</span>
<span class="sd">        Parameter errors are also returned in .perror.</span>

<span class="sd">        To compute the correlation matrix, pcor, use this example:</span>
<span class="sd">           cov = mpfit.covar</span>
<span class="sd">           pcor = cov * 0.</span>
<span class="sd">           for i in range(n):</span>
<span class="sd">              for j in range(n):</span>
<span class="sd">                 pcor[i,j] = cov[i,j]/sqrt(cov[i,i]*cov[j,j])</span>

<span class="sd">        If nocovar is set or MPFIT terminated abnormally, then .covar is set to</span>
<span class="sd">        a scalar with value None.</span>

<span class="sd">     .errmsg</span>
<span class="sd">        A string error or warning message is returned.</span>

<span class="sd">     .nfev</span>
<span class="sd">        The number of calls to MYFUNCT performed.</span>

<span class="sd">     .niter</span>
<span class="sd">        The number of iterations completed.</span>

<span class="sd">     .perror</span>
<span class="sd">        The formal 1-sigma errors in each parameter, computed from the</span>
<span class="sd">        covariance matrix.  If a parameter is held fixed, or if it touches a</span>
<span class="sd">        boundary, then the error is reported as zero.</span>

<span class="sd">        If the fit is unweighted (i.e. no errors were given, or the weights</span>
<span class="sd">        were uniformly set to unity), then .perror will probably not represent</span>
<span class="sd">        the true parameter uncertainties.</span>

<span class="sd">        *If* you can assume that the true reduced chi-squared value is unity --</span>
<span class="sd">        meaning that the fit is implicitly assumed to be of good quality --</span>
<span class="sd">        then the estimated parameter uncertainties can be computed by scaling</span>
<span class="sd">        .perror by the measured chi-squared value.</span>

<span class="sd">           dof = len(x) - len(mpfit.params) # deg of freedom</span>
<span class="sd">           # scaled uncertainties</span>
<span class="sd">           pcerror = mpfit.perror * sqrt(mpfit.fnorm / dof)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covar</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perror</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># Invalid input flag set while we check inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="n">debug</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfev</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damp</span> <span class="o">=</span> <span class="n">damp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">fcn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&quot;Usage: parms = mpfit(&#39;myfunt&#39;, ... )&quot;</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">iterfunct</span> <span class="o">==</span> <span class="s">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">iterfunct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defiter</span>

        <span class="c"># Parameter damping doesn&#39;t work when user is providing their own</span>
        <span class="c"># gradients.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">damp</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">autoderivative</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: keywords DAMP and AUTODERIVATIVE are mutually exclusive&#39;</span>
            <span class="k">return</span>

        <span class="c"># Parameters can either be stored in parinfo, or x. x takes precedence</span>
        <span class="c"># if it exists</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xall</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">parinfo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: must pass parameters in P or PARINFO&#39;</span>
            <span class="k">return</span>

        <span class="c"># Be sure that PARINFO is of the right type</span>
        <span class="k">if</span> <span class="n">parinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: PARINFO must be a list of dictionaries.&#39;</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parinfo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: PARINFO must be a list of dictionaries.&#39;</span>
                    <span class="k">return</span>
            <span class="k">if</span> <span class="p">((</span><span class="n">xall</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xall</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parinfo</span><span class="p">))):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: number of elements in PARINFO and P must agree&#39;</span>
                <span class="k">return</span>

        <span class="c"># If the parameters were not specified at the command line, then</span>
        <span class="c"># extract them from PARINFO</span>
        <span class="k">if</span> <span class="n">xall</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xall</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;value&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xall</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: either P or PARINFO(*)[&quot;value&quot;] must be supplied.&#39;</span>
                <span class="k">return</span>

        <span class="c"># Make sure parameters are numpy arrays</span>
        <span class="n">xall</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xall</span><span class="p">)</span>
        <span class="c"># In the case if the xall is not float or if is float but has less</span>
        <span class="c"># than 64 bits we do convert it into double</span>
        <span class="k">if</span> <span class="n">xall</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">!=</span> <span class="s">&#39;f&#39;</span> <span class="ow">or</span> <span class="n">xall</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">xall</span> <span class="o">=</span> <span class="n">xall</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="n">npar</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xall</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
        <span class="n">fnorm1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>

        <span class="c"># TIED parameters?</span>
        <span class="n">ptied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;tied&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qanytied</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npar</span><span class="p">):</span>
            <span class="n">ptied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ptied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qanytied</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptied</span> <span class="o">=</span> <span class="n">ptied</span>

        <span class="c"># FIXED parameters ?</span>
        <span class="n">pfixed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;fixed&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>
        <span class="n">pfixed</span> <span class="o">=</span> <span class="p">(</span><span class="n">pfixed</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">npar</span><span class="p">):</span>
            <span class="n">pfixed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pfixed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ptied</span><span class="p">[</span>
                                      <span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">)</span>  <span class="c"># Tied parameters are also effectively fixed</span>

        <span class="c"># Finite differencing step, absolute and relative, and sidedness of</span>
        <span class="c"># deriv.</span>
        <span class="n">step</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;step&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>
        <span class="n">dstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;relstep&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>
        <span class="n">dside</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;mpside&#39;</span><span class="p">,</span>  <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>

        <span class="c"># Maximum and minimum steps allowed to be taken in one iteration</span>
        <span class="n">maxstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;mpmaxstep&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>
        <span class="n">minstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;mpminstep&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>
        <span class="n">qmin</span> <span class="o">=</span> <span class="n">minstep</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="n">qmin</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c"># Remove minstep for now!!</span>
        <span class="n">qmax</span> <span class="o">=</span> <span class="n">maxstep</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">qmin</span> <span class="o">&amp;</span> <span class="n">qmax</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">maxstep</span> <span class="o">&lt;</span> <span class="n">minstep</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: MPMINSTEP is greater than MPMAXSTEP&#39;</span>
            <span class="k">return</span>
        <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">qmin</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">qmax</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">qminmax</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c"># Finish up the free parameters</span>
        <span class="n">ifree</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">pfixed</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nfree</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nfree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: no free parameters&#39;</span>
            <span class="k">return</span>

        <span class="c"># Compose only VARYING parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">xall</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                                <span class="c"># self.params is the set of parameters to be</span>
                                <span class="c"># returned</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span>  <span class="c"># x is the set of free parameters</span>

        <span class="c"># LIMITED parameters ?</span>
        <span class="n">limited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;limited&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>
        <span class="n">limits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parinfo</span><span class="p">(</span><span class="n">parinfo</span><span class="p">,</span> <span class="s">&#39;limits&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">npar</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">limited</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">limits</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="c"># Error checking on limits in parinfo</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">limited</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xall</span> <span class="o">&lt;</span> <span class="n">limits</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">|</span>
                        <span class="p">(</span><span class="n">limited</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xall</span> <span class="o">&gt;</span> <span class="n">limits</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: parameters are not within PARINFO limits&#39;</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">limited</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">limited</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                        <span class="p">(</span><span class="n">limits</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">limits</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span>
                        <span class="p">(</span><span class="n">pfixed</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: PARINFO parameter limits are not consistent&#39;</span>
                <span class="k">return</span>

            <span class="c"># Transfer structure values to local variables</span>
            <span class="n">qulim</span> <span class="o">=</span> <span class="p">(</span><span class="n">limited</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])[</span><span class="n">ifree</span><span class="p">]</span>
            <span class="n">ulim</span> <span class="o">=</span> <span class="p">(</span><span class="n">limits</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])[</span><span class="n">ifree</span><span class="p">]</span>
            <span class="n">qllim</span> <span class="o">=</span> <span class="p">(</span><span class="n">limited</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])[</span><span class="n">ifree</span><span class="p">]</span>
            <span class="n">llim</span> <span class="o">=</span> <span class="p">(</span><span class="n">limits</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])[</span><span class="n">ifree</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">qulim</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">qllim</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)):</span>
                <span class="n">qanylim</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">qanylim</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Fill in local variables with dummy values</span>
            <span class="n">qulim</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nfree</span><span class="p">)</span>
            <span class="n">ulim</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">0.</span>
            <span class="n">qllim</span> <span class="o">=</span> <span class="n">qulim</span>
            <span class="n">llim</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">0.</span>
            <span class="n">qanylim</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c"># Check input parameters for errors</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ftol</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xtol</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">gtol</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> \
                <span class="ow">or</span> <span class="p">(</span><span class="n">maxiter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">factor</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: input keywords are inconsistent&#39;</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">rescale</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: DIAG parameter scales are inconsistent&#39;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">diag</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">fvec</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">functkw</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: first call to &quot;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;&quot; failed&#39;</span>
            <span class="k">return</span>
        <span class="c"># If the returned fvec has more than four bits I assume that we have</span>
        <span class="c"># double precision</span>
        <span class="c"># It is important that the machar is determined by the precision of</span>
        <span class="c"># the returned value, not by the precision of the input array</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fvec</span><span class="p">])</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">machar</span> <span class="o">=</span> <span class="n">machar</span><span class="p">(</span><span class="n">double</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blas_enorm</span> <span class="o">=</span> <span class="n">mpfit</span><span class="o">.</span><span class="n">blas_enorm64</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">machar</span> <span class="o">=</span> <span class="n">machar</span><span class="p">(</span><span class="n">double</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blas_enorm</span> <span class="o">=</span> <span class="n">mpfit</span><span class="o">.</span><span class="n">blas_enorm32</span>
        <span class="n">machep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">machar</span><span class="o">.</span><span class="n">machep</span>

        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fvec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;ERROR: number of parameters must not exceed data&#39;</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dof</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">nfree</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">fvec</span><span class="p">)</span>

        <span class="c"># Initialize Levelberg-Marquardt parameter and iteration counter</span>

        <span class="n">par</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">qtf</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># Beginning of the outer loop</span>

        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>

            <span class="c"># If requested, call fcn to enable printing of iterates</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qanytied</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tie</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">ptied</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">nprint</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iterfunct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">nprint</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c">#mperr = 0</span>
                    <span class="n">xnew0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                    <span class="n">dof</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">fvec</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
                    <span class="n">status</span> <span class="o">=</span> <span class="n">iterfunct</span><span class="p">(</span>
                        <span class="n">fcn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="n">functkw</span><span class="o">=</span><span class="n">functkw</span><span class="p">,</span> <span class="n">parinfo</span><span class="o">=</span><span class="n">parinfo</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="n">quiet</span><span class="p">,</span>
                        <span class="n">dof</span><span class="o">=</span><span class="n">dof</span><span class="p">,</span> <span class="o">**</span><span class="n">iterkw</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">status</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="n">status</span>

                    <span class="c"># Check for user termination</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;WARNING: premature termination by &#39;</span> <span class="o">+</span> \
                            <span class="nb">str</span><span class="p">(</span><span class="n">iterfunct</span><span class="p">)</span>
                        <span class="k">return</span>

                    <span class="c"># If parameters were changed (grrr..) then re-tie</span>
                    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xnew0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qanytied</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tie</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">ptied</span><span class="p">)</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span>

            <span class="c"># Calculate the jacobian matrix</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;calling MPFIT_FDJAC2&#39;</span>
            <span class="n">fjac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fdjac2</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fvec</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">qulim</span><span class="p">,</span> <span class="n">ulim</span><span class="p">,</span> <span class="n">dside</span><span class="p">,</span>
                               <span class="n">epsfcn</span><span class="o">=</span><span class="n">epsfcn</span><span class="p">,</span>
                               <span class="n">autoderivative</span><span class="o">=</span><span class="n">autoderivative</span><span class="p">,</span> <span class="n">dstep</span><span class="o">=</span><span class="n">dstep</span><span class="p">,</span>
                               <span class="n">functkw</span><span class="o">=</span><span class="n">functkw</span><span class="p">,</span> <span class="n">ifree</span><span class="o">=</span><span class="n">ifree</span><span class="p">,</span> <span class="n">xall</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fjac</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;WARNING: premature termination by FDJAC2&#39;</span>
                <span class="k">return</span>

            <span class="c"># Determine if any of the parameters are pegged at the limits</span>
            <span class="k">if</span> <span class="n">qanylim</span><span class="p">:</span>
                <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;zeroing derivatives of pegged parameters&#39;</span>
                <span class="n">whlpeg</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">qllim</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">llim</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nlpeg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">whlpeg</span><span class="p">)</span>
                <span class="n">whupeg</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">qulim</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">ulim</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">nupeg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">whupeg</span><span class="p">)</span>
                <span class="c"># See if any &quot;pegged&quot; values should keep their derivatives</span>
                <span class="k">if</span> <span class="n">nlpeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># Total derivative of sum wrt lower pegged parameters</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nlpeg</span><span class="p">):</span>
                        <span class="n">sum0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fvec</span> <span class="o">*</span> <span class="n">fjac</span><span class="p">[:,</span> <span class="n">whlpeg</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                        <span class="k">if</span> <span class="n">sum0</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">fjac</span><span class="p">[:,</span> <span class="n">whlpeg</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">nupeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c"># Total derivative of sum wrt upper pegged parameters</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nupeg</span><span class="p">):</span>
                        <span class="n">sum0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fvec</span> <span class="o">*</span> <span class="n">fjac</span><span class="p">[:,</span> <span class="n">whupeg</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                        <span class="k">if</span> <span class="n">sum0</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">fjac</span><span class="p">[:,</span> <span class="n">whupeg</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c"># Compute the QR factorization of the jacobian</span>
            <span class="p">[</span><span class="n">fjac</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">wa1</span><span class="p">,</span> <span class="n">wa2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qrfac</span><span class="p">(</span><span class="n">fjac</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="c"># On the first iteration if &quot;diag&quot; is unspecified, scale</span>
            <span class="c"># according to the norms of the columns of the initial jacobian</span>
            <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;rescaling diagonal elements&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">rescale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">diag</span> <span class="o">=</span> <span class="n">wa2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">diag</span><span class="p">[</span><span class="n">diag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

                <span class="c"># On the first iteration, calculate the norm of the scaled x</span>
                <span class="c"># and initialize the step bound delta</span>
                <span class="n">wa3</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">x</span>
                <span class="n">xnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa3</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">factor</span><span class="o">*</span><span class="n">xnorm</span>
                <span class="k">if</span> <span class="n">delta</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">factor</span>

            <span class="c"># Form (q transpose)*fvec and store the first n components in qtf</span>
            <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;forming (q transpose)*fvec&#39;</span>
            <span class="n">wa4</span> <span class="o">=</span> <span class="n">fvec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">lj</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">temp3</span> <span class="o">=</span> <span class="n">fjac</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">lj</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">temp3</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">fj</span> <span class="o">=</span> <span class="n">fjac</span><span class="p">[</span><span class="n">j</span><span class="p">:,</span> <span class="n">lj</span><span class="p">]</span>
                    <span class="n">wj</span> <span class="o">=</span> <span class="n">wa4</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span>
                    <span class="c"># *** optimization wa4(j:*)</span>
                    <span class="n">wa4</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span> <span class="o">=</span> <span class="n">wj</span> <span class="o">-</span> <span class="n">fj</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fj</span><span class="o">*</span><span class="n">wj</span><span class="p">)</span> <span class="o">/</span> <span class="n">temp3</span>
                <span class="n">fjac</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">lj</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">qtf</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa4</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="c"># From this point on, only the square matrix, consisting of the</span>
            <span class="c"># triangle of R, is needed.</span>
            <span class="n">fjac</span> <span class="o">=</span> <span class="n">fjac</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
            <span class="n">fjac</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">fjac</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">temp</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fjac</span><span class="p">[:,</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">fjac</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="c"># Check for overflow.  This should be a cheap test here since FJAC</span>
            <span class="c"># has been reduced to a (small) square matrix, and the test is</span>
            <span class="c"># O(N^2).</span>
            <span class="c"># wh = where(finite(fjac) EQ 0, ct)</span>
            <span class="c"># if ct GT 0 then goto, FAIL_OVERFLOW</span>

            <span class="c"># Compute the norm of the scaled gradient</span>
            <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;computing the scaled gradient&#39;</span>
            <span class="n">gnorm</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">wa2</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">sum0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fjac</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">qtf</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span>
                        <span class="n">gnorm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">gnorm</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sum0</span><span class="o">/</span><span class="n">wa2</span><span class="p">[</span><span class="n">l</span><span class="p">])])</span>

            <span class="c"># Test for convergence of the gradient norm</span>
            <span class="k">if</span> <span class="n">gnorm</span> <span class="o">&lt;=</span> <span class="n">gtol</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">4</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">maxiter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="k">break</span>

            <span class="c"># Rescale if necessary</span>
            <span class="k">if</span> <span class="n">rescale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">diag</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">diag</span> <span class="o">&gt;</span> <span class="n">wa2</span><span class="p">,</span> <span class="p">(</span><span class="n">wa2</span><span class="p">,</span> <span class="n">diag</span><span class="p">))</span>

            <span class="c"># Beginning of the inner loop</span>
            <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>

                <span class="c"># Determine the levenberg-marquardt parameter</span>
                <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;calculating LM parameter (MPFIT_)&#39;</span>
                <span class="p">[</span><span class="n">fjac</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="n">wa1</span><span class="p">,</span> <span class="n">wa2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lmpar</span><span class="p">(</span><span class="n">fjac</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">qtf</span><span class="p">,</span>
                                                   <span class="n">delta</span><span class="p">,</span> <span class="n">wa1</span><span class="p">,</span> <span class="n">wa2</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="n">par</span><span class="p">)</span>
                <span class="c"># Store the direction p and x+p. Calculate the norm of p</span>
                <span class="n">wa1</span> <span class="o">=</span> <span class="o">-</span><span class="n">wa1</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">qanylim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">qminmax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="c"># No parameter limits, so just move to new position WA2</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="n">wa2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">wa1</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="c"># Respect the limits.  If a step were to go out of bounds, then</span>
                    <span class="c"># we should take a step in the same direction but shorter distance.</span>
                    <span class="c"># The step should take us right to the limit in that case.</span>
                    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.</span>

                    <span class="k">if</span> <span class="n">qanylim</span><span class="p">:</span>
                        <span class="c"># Do not allow any steps out of bounds</span>
                        <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;checking for a step out of bounds&#39;</span>
                        <span class="k">if</span> <span class="n">nlpeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">wa1</span><span class="p">[</span><span class="n">whlpeg</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">wa1</span><span class="p">[</span>
                                                     <span class="n">whlpeg</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">wa1</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">nupeg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">wa1</span><span class="p">[</span><span class="n">whupeg</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">wa1</span><span class="p">[</span>
                                                     <span class="n">whupeg</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">wa1</span><span class="p">),</span> <span class="mf">0.</span><span class="p">)</span>

                        <span class="n">dwa1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">wa1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">machep</span>
                        <span class="n">whl</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(((</span>
                            <span class="n">dwa1</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">qllim</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">wa1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">llim</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">whl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="p">((</span><span class="n">llim</span><span class="p">[</span><span class="n">whl</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">whl</span><span class="p">])</span> <span class="o">/</span>
                                 <span class="n">wa1</span><span class="p">[</span><span class="n">whl</span><span class="p">])</span>
                            <span class="n">alpha</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span>
                        <span class="n">whu</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(((</span>
                            <span class="n">dwa1</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">qulim</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="n">wa1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">ulim</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">whu</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">t</span> <span class="o">=</span> <span class="p">((</span><span class="n">ulim</span><span class="p">[</span><span class="n">whu</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">whu</span><span class="p">])</span> <span class="o">/</span>
                                 <span class="n">wa1</span><span class="p">[</span><span class="n">whu</span><span class="p">])</span>
                            <span class="n">alpha</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">alpha</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">t</span><span class="p">)])</span>

                    <span class="c"># Obey any max step values.</span>
                    <span class="k">if</span> <span class="n">qminmax</span><span class="p">:</span>
                        <span class="n">nwa1</span> <span class="o">=</span> <span class="n">wa1</span> <span class="o">*</span> <span class="n">alpha</span>
                        <span class="n">whmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span>
                            <span class="n">qmax</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">maxstep</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">whmax</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">mrat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nwa1</span><span class="p">[</span><span class="n">whmax</span><span class="p">])</span> <span class="o">/</span>
                                             <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">maxstep</span><span class="p">[</span><span class="n">ifree</span><span class="p">[</span><span class="n">whmax</span><span class="p">]]))</span>
                            <span class="k">if</span> <span class="n">mrat</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">mrat</span>

                    <span class="c"># Scale the resulting vector</span>
                    <span class="n">wa1</span> <span class="o">=</span> <span class="n">wa1</span> <span class="o">*</span> <span class="n">alpha</span>
                    <span class="n">wa2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">wa1</span>

                    <span class="c"># Adjust the final output values.  If the step put us exactly</span>
                    <span class="c"># on a boundary, make sure it is exact.</span>
                    <span class="n">sgnu</span> <span class="o">=</span> <span class="p">(</span><span class="n">ulim</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">-</span> <span class="mf">1.</span>
                    <span class="n">sgnl</span> <span class="o">=</span> <span class="p">(</span><span class="n">llim</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">-</span> <span class="mf">1.</span>
                    <span class="c"># Handles case of</span>
                    <span class="c">#        ... nonzero *LIM ... ...zero * LIM</span>
                    <span class="n">ulim1</span> <span class="o">=</span> <span class="n">ulim</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sgnu</span> <span class="o">*</span> <span class="n">machep</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">ulim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">machep</span>
                    <span class="n">llim1</span> <span class="o">=</span> <span class="n">llim</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">sgnl</span> <span class="o">*</span> <span class="n">machep</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">llim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">machep</span>
                    <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">qulim</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wa2</span> <span class="o">&gt;=</span> <span class="n">ulim1</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">wa2</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span> <span class="o">=</span> <span class="n">ulim</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span>
                    <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">qllim</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">wa2</span> <span class="o">&lt;=</span> <span class="n">llim1</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">wa2</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span> <span class="o">=</span> <span class="n">llim</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span>
                <span class="c"># endelse</span>
                <span class="n">wa3</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">wa1</span>
                <span class="n">pnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa3</span><span class="p">)</span>

                <span class="c"># On the first iteration, adjust the initial step bound</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">delta</span><span class="p">,</span> <span class="n">pnorm</span><span class="p">])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa2</span>

                <span class="c"># Evaluate the function at x+p and calculate its norm</span>
                <span class="c">#mperr = 0</span>
                <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;calling &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">,</span> <span class="n">wa4</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">functkw</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s">&#39;WARNING: premature termination by &quot;&#39;</span> <span class="o">+</span> <span class="n">fcn</span> <span class="o">+</span> <span class="s">&#39;&quot;&#39;</span>
                    <span class="k">return</span>
                <span class="n">fnorm1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa4</span><span class="p">)</span>

                <span class="c"># Compute the scaled actual reduction</span>
                <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;computing convergence criteria&#39;</span>
                <span class="n">actred</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span>
                <span class="k">if</span> <span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">fnorm1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span><span class="p">:</span>
                    <span class="n">actred</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">fnorm1</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">1.</span>

                <span class="c"># Compute the scaled predicted reduction and the scaled directional</span>
                <span class="c"># derivative</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">wa3</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">wa3</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa3</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">fjac</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">wa1</span><span class="p">[</span><span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>

                <span class="c"># Remember, alpha is the fraction of the full LM step actually</span>
                <span class="c"># taken</span>
                <span class="n">temp1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">wa3</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span>
                <span class="n">temp2</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">par</span><span class="p">)</span><span class="o">*</span><span class="n">pnorm</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span>
                <span class="n">prered</span> <span class="o">=</span> <span class="n">temp1</span><span class="o">*</span><span class="n">temp1</span> <span class="o">+</span> <span class="p">(</span><span class="n">temp2</span><span class="o">*</span><span class="n">temp2</span><span class="p">)</span><span class="o">/</span><span class="mf">0.5</span>
                <span class="n">dirder</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">temp1</span><span class="o">*</span><span class="n">temp1</span> <span class="o">+</span> <span class="n">temp2</span><span class="o">*</span><span class="n">temp2</span><span class="p">)</span>

                <span class="c"># Compute the ratio of the actual to the predicted reduction.</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="k">if</span> <span class="n">prered</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ratio</span> <span class="o">=</span> <span class="n">actred</span><span class="o">/</span><span class="n">prered</span>

                <span class="c"># Update the step bound</span>
                <span class="k">if</span> <span class="n">ratio</span> <span class="o">&lt;=</span> <span class="mf">0.25</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">actred</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">dirder</span><span class="o">/</span><span class="p">(</span><span class="n">dirder</span> <span class="o">+</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">actred</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">((</span><span class="mf">0.1</span><span class="o">*</span><span class="n">fnorm1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">):</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="mf">0.1</span>
                    <span class="n">delta</span> <span class="o">=</span> <span class="n">temp</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">delta</span><span class="p">,</span> <span class="n">pnorm</span><span class="o">/</span><span class="mf">0.1</span><span class="p">])</span>
                    <span class="n">par</span> <span class="o">=</span> <span class="n">par</span><span class="o">/</span><span class="n">temp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">par</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">&gt;=</span> <span class="mf">0.75</span><span class="p">):</span>
                        <span class="n">delta</span> <span class="o">=</span> <span class="n">pnorm</span><span class="o">/.</span><span class="mi">5</span>
                        <span class="n">par</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="o">*</span><span class="n">par</span>

                <span class="c"># Test for successful iteration</span>
                <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;=</span> <span class="mf">0.0001</span><span class="p">:</span>
                    <span class="c"># Successful iteration.  Update x, fvec, and their norms</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">wa2</span>
                    <span class="n">wa2</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">x</span>
                    <span class="n">fvec</span> <span class="o">=</span> <span class="n">wa4</span>
                    <span class="n">xnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa2</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">=</span> <span class="n">fnorm1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c"># Tests for convergence</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">actred</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ftol</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">prered</span> <span class="o">&lt;=</span> <span class="n">ftol</span><span class="p">)</span> \
                        <span class="ow">and</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">xtol</span><span class="o">*</span><span class="n">xnorm</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">actred</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">ftol</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">prered</span> <span class="o">&lt;=</span> <span class="n">ftol</span><span class="p">)</span> \
                        <span class="ow">and</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c"># Tests for termination and stringent tolerances</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span> <span class="o">&gt;=</span> <span class="n">maxiter</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">5</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">actred</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">machep</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">prered</span> <span class="o">&lt;=</span> <span class="n">machep</span><span class="p">)</span> \
                        <span class="ow">and</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">ratio</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">6</span>
                <span class="k">if</span> <span class="n">delta</span> <span class="o">&lt;=</span> <span class="n">machep</span> <span class="o">*</span> <span class="n">xnorm</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">7</span>
                <span class="k">if</span> <span class="n">gnorm</span> <span class="o">&lt;=</span> <span class="n">machep</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="mi">8</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c"># End of inner loop. Repeat if iteration unsuccessful</span>
                <span class="k">if</span> <span class="n">ratio</span> <span class="o">&gt;=</span> <span class="mf">0.0001</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="c"># Check for over/underflow</span>
                <span class="k">if</span> <span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">wa1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">wa2</span><span class="p">)</span> <span class="o">&amp;</span>
                              <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="ow">or</span> <span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ratio</span><span class="p">):</span>
                    <span class="c">#errmsg = (&#39;&#39;&#39;ERROR: parameter or function value(s) have become</span>
                    <span class="c">#    &#39;infinite; check model function for over- &#39;and underflow&#39;&#39;&#39;)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="mi">16</span>
                    <span class="k">break</span>
                <span class="c"># wh = where(finite(wa1) EQ 0 OR finite(wa2) EQ 0 OR finite(x) EQ 0, ct)</span>
                <span class="c"># if ct GT 0 OR finite(ratio) EQ 0 then begin</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="c"># End of outer loop.</span>

        <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;in the termination phase&#39;</span>
        <span class="c"># Termination, either normal or user imposed.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">nfree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">xall</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nprint</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">catch_msg</span> <span class="o">=</span> <span class="s">&#39;calling &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fcn</span><span class="p">)</span>
            <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">fvec</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">functkw</span><span class="p">)</span>
            <span class="c">#catch_msg = &#39;in the termination phase&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">fvec</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fnorm1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span><span class="p">,</span> <span class="n">fnorm1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fnorm</span> <span class="o">**</span> <span class="mf">2.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">covar</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perror</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># (very carefully) set the covariance matrix COVAR</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">status</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nocovar</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> \
                <span class="ow">and</span> <span class="p">(</span><span class="n">fjac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ipvt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">sz</span> <span class="o">=</span> <span class="n">fjac</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span> \
                    <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ipvt</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">):</span>

                <span class="c">#catch_msg = &#39;computing the covariance matrix&#39;</span>
                <span class="n">cv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_covar</span><span class="p">(</span><span class="n">fjac</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">],</span> <span class="n">ipvt</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">n</span><span class="p">])</span>
                <span class="n">cv</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                <span class="n">nn</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xall</span><span class="p">)</span>

                <span class="c"># Fill in actual covariance matrix, accounting for fixed</span>
                <span class="c"># parameters.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">covar</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nn</span><span class="p">,</span> <span class="n">nn</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">covar</span><span class="p">[</span><span class="n">ifree</span><span class="p">,</span> <span class="n">ifree</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">cv</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

                <span class="c"># Compute errors in parameters</span>
                <span class="c">#catch_msg = &#39;computing parameter errors&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">perror</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covar</span><span class="p">)</span>
                <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">perror</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">wh</span><span class="p">])</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">&#39;params&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="s">&#39;niter&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">niter</span><span class="p">,</span>
                <span class="s">&#39;params&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="s">&#39;covar&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">covar</span><span class="p">,</span>
                <span class="s">&#39;perror&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">perror</span><span class="p">,</span>
                <span class="s">&#39;status&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">status</span><span class="p">,</span>
                <span class="s">&#39;debug&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">,</span>
                <span class="s">&#39;errmsg&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span>
                <span class="s">&#39;nfev&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfev</span><span class="p">,</span>
                <span class="s">&#39;damp&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">damp</span>
                <span class="c">#,&#39;machar&#39;:self.machar</span>
                <span class="p">}</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>

    <span class="c"># Default procedure to be called every iteration.  It simply prints</span>
    <span class="c"># the parameter values.</span>
<div class="viewcode-block" id="mpfit.defiter"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.defiter">[docs]</a>    <span class="k">def</span> <span class="nf">defiter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="nb">iter</span><span class="p">,</span> <span class="n">fnorm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">functkw</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">quiet</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">iterstop</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">parinfo</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pformat</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%.10g</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering defiter...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">quiet</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">fnorm</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">fvec</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">functkw</span><span class="p">)</span>
            <span class="n">fnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">fvec</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="c"># Determine which parameters to print</span>
        <span class="n">nprint</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">print</span> <span class="p">(</span><span class="s">&quot;Iter &quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;</span><span class="si">%6i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">iter</span><span class="p">),</span> <span class="s">&quot;   CHI-SQUARE = &quot;</span><span class="p">,</span> <span class="p">(</span>
            <span class="s">&#39;</span><span class="si">%.10g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fnorm</span><span class="p">),</span> <span class="s">&quot; DOF = &quot;</span><span class="p">,</span> <span class="p">(</span><span class="s">&#39;</span><span class="si">%i</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dof</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nprint</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;parname&#39;</span> <span class="ow">in</span> <span class="n">parinfo</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="s">&#39;   &#39;</span> <span class="o">+</span> <span class="n">parinfo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">&#39;parname&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39; = &#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="s">&#39;   P&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; = &#39;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;mpprint&#39;</span> <span class="ow">in</span> <span class="n">parinfo</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">iprint</span> <span class="o">=</span> <span class="n">parinfo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">&#39;mpprint&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">iprint</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">iprint</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="p">(</span><span class="n">pformat</span> <span class="o">%</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;  &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="c">#  DO_ITERSTOP:</span>
    <span class="c">#  if keyword_set(iterstop) then begin</span>
    <span class="c">#     k = get_kbrd(0)</span>
    <span class="c">#     if k EQ string(byte(7)) then begin</span>
    <span class="c">#         message, &#39;WARNING: minimization not complete&#39;, /info</span>
    <span class="c">#         print, &#39;Do you want to terminate this procedure? (y/n)&#39;, $</span>
    <span class="c">#           format=&#39;(A,$)&#39;</span>
    <span class="c">#         k = &#39;&#39;</span>
    <span class="c">#         read, k</span>
    <span class="c">#         if strupcase(strmid(k,0,1)) EQ &#39;Y&#39; then begin</span>
    <span class="c">#             message, &#39;WARNING: Procedure is terminating.&#39;, /info</span>
    <span class="c">#             mperr = -1</span>
    <span class="c">#         endif</span>
    <span class="c">#     endif</span>
    <span class="c">#  endif</span>

    <span class="c"># Procedure to parse the parameter values in PARINFO, which is a list of</span>
    <span class="c"># dictionaries</span></div>
<div class="viewcode-block" id="mpfit.parinfo"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.parinfo">[docs]</a>    <span class="k">def</span> <span class="nf">parinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parinfo</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering parinfo...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">parinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parinfo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">default</span>

            <span class="k">return</span> <span class="n">values</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parinfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">key</span> <span class="ow">in</span> <span class="n">parinfo</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parinfo</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>

        <span class="c"># Convert to numeric arrays if possible</span>
        <span class="n">test</span> <span class="o">=</span> <span class="n">default</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">test</span> <span class="o">=</span> <span class="n">default</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">values</span>

    <span class="c"># Call user function or procedure, with _EXTRA or not, with</span>
    <span class="c"># derivatives or not.</span></div>
<div class="viewcode-block" id="mpfit.call"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.call">[docs]</a>    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">functkw</span><span class="p">,</span> <span class="n">fjac</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering call...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">qanytied</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tie</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptied</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nfev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfev</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">fjac</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fjac</span><span class="o">=</span><span class="n">fjac</span><span class="p">,</span> <span class="o">**</span><span class="n">functkw</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">damp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Apply the damping if requested.  This replaces the residuals</span>
                <span class="c"># with their hyperbolic tangent.  Thus residuals larger than</span>
                <span class="c"># DAMP are essentially clipped.</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">f</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">damp</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">f</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fjac</span><span class="o">=</span><span class="n">fjac</span><span class="p">,</span> <span class="o">**</span><span class="n">functkw</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="mpfit.enorm"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.enorm">[docs]</a>    <span class="k">def</span> <span class="nf">enorm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blas_enorm</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ans</span>
</div>
<div class="viewcode-block" id="mpfit.fdjac2"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.fdjac2">[docs]</a>    <span class="k">def</span> <span class="nf">fdjac2</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">fvec</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ulimited</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ulimit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dside</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">epsfcn</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">autoderivative</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">functkw</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">xall</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ifree</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dstep</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering fdjac2...&#39;</span><span class="p">)</span>
        <span class="n">machep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">machar</span><span class="o">.</span><span class="n">machep</span>
        <span class="k">if</span> <span class="n">epsfcn</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">epsfcn</span> <span class="o">=</span> <span class="n">machep</span>
        <span class="k">if</span> <span class="n">xall</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xall</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">ifree</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ifree</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xall</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mf">0.</span>
        <span class="n">nall</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xall</span><span class="p">)</span>

        <span class="n">eps</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">epsfcn</span><span class="p">,</span> <span class="n">machep</span><span class="p">]))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fvec</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c"># Compute analytical derivative if requested</span>
        <span class="k">if</span> <span class="n">autoderivative</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c">#mperr = 0</span>
            <span class="n">fjac</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nall</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">fjac</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c"># Specify which parameters need derivatives</span>
            <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">fp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">xall</span><span class="p">,</span> <span class="n">functkw</span><span class="p">,</span> <span class="n">fjac</span><span class="o">=</span><span class="n">fjac</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fjac</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">nall</span><span class="p">:</span>
                <span class="k">print</span> <span class="p">(</span><span class="s">&#39;ERROR: Derivative matrix was not computed properly.&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">None</span>

            <span class="c"># This definition is consistent with CURVEFIT</span>
            <span class="c"># Sign error found (thanks Jesus Fernandez</span>
            <span class="c"># &lt;fernande@irm.chu-caen.fr&gt;)</span>
            <span class="n">fjac</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">nall</span><span class="p">]</span>
            <span class="n">fjac</span> <span class="o">=</span> <span class="o">-</span><span class="n">fjac</span>

            <span class="c"># Select only the free parameters</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ifree</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nall</span><span class="p">:</span>
                <span class="n">fjac</span> <span class="o">=</span> <span class="n">fjac</span><span class="p">[:,</span> <span class="n">ifree</span><span class="p">]</span>
                <span class="n">fjac</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">fjac</span>

        <span class="n">fjac</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">h</span> <span class="o">=</span> <span class="n">eps</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c"># if STEP is given, use that</span>
        <span class="c"># STEP includes the fixed parameters</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stepi</span> <span class="o">=</span> <span class="n">step</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">stepi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">h</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span> <span class="o">=</span> <span class="n">stepi</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span>

        <span class="c"># if relative step is given, use that</span>
        <span class="c"># DSTEP includes the fixed parameters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dstep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dstepi</span> <span class="o">=</span> <span class="n">dstep</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">dstepi</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">h</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dstepi</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">wh</span><span class="p">])</span>

        <span class="c"># In case any of the step values are zero</span>
        <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">eps</span>

        <span class="c"># Reverse the sign of the step if we are up against the parameter</span>
        <span class="c"># limit, or if the user requested it.</span>
        <span class="c"># DSIDE includes the fixed parameters (ULIMITED/ULIMIT have only</span>
        <span class="c"># varying ones)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">dside</span><span class="p">[</span><span class="n">ifree</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ulimited</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ulimit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">|</span> <span class="p">((</span><span class="n">ulimited</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">ulimit</span><span class="o">-</span><span class="n">h</span><span class="p">)))</span>
            <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">h</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">wh</span><span class="p">]</span>
        <span class="c"># Loop through parameters, computing the derivative for each</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">xp</span> <span class="o">=</span> <span class="n">xall</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">xp</span><span class="p">[</span><span class="n">ifree</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">xp</span><span class="p">[</span><span class="n">ifree</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">fp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">functkw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dside</span><span class="p">[</span><span class="n">ifree</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># COMPUTE THE ONE-SIDED DERIVATIVE</span>
                <span class="c"># Note optimization fjac(0:*,j)</span>
                <span class="n">fjac</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fp</span><span class="o">-</span><span class="n">fvec</span><span class="p">)</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c"># COMPUTE THE TWO-SIDED DERIVATIVE</span>
                <span class="n">xp</span><span class="p">[</span><span class="n">ifree</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">xall</span><span class="p">[</span><span class="n">ifree</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="c">#mperr = 0</span>
                <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">fm</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">functkw</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">None</span>

                <span class="c"># Note optimization fjac(0:*,j)</span>
                <span class="n">fjac</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fp</span><span class="o">-</span><span class="n">fm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fjac</span>

    <span class="c">#    Original FORTRAN documentation</span>
    <span class="c">#    **********</span>
    <span class="c">#</span>
    <span class="c">#    subroutine qrfac</span>
    <span class="c">#</span>
    <span class="c">#    this subroutine uses householder transformations with column</span>
    <span class="c">#    pivoting (optional) to compute a qr factorization of the</span>
    <span class="c">#    m by n matrix a. that is, qrfac determines an orthogonal</span>
    <span class="c">#    matrix q, a permutation matrix p, and an upper trapezoidal</span>
    <span class="c">#    matrix r with diagonal elements of nonincreasing magnitude,</span>
    <span class="c">#    such that a*p = q*r. the householder transformation for</span>
    <span class="c">#    column k, k = 1,2,...,min(m,n), is of the form</span>
    <span class="c">#</span>
    <span class="c">#                       t</span>
    <span class="c">#       i - (1/u(k))*u*u</span>
    <span class="c">#</span>
    <span class="c">#    where u has zeros in the first k-1 positions. the form of</span>
    <span class="c">#    this transformation and the method of pivoting first</span>
    <span class="c">#    appeared in the corresponding linpack subroutine.</span>
    <span class="c">#</span>
    <span class="c">#    the subroutine statement is</span>
    <span class="c">#</span>
    <span class="c">#   subroutine qrfac(m,n,a,lda,pivot,ipvt,lipvt,rdiag,acnorm,wa)</span>
    <span class="c">#</span>
    <span class="c">#    where</span>
    <span class="c">#</span>
    <span class="c">#   m is a positive integer input variable set to the number</span>
    <span class="c">#     of rows of a.</span>
    <span class="c">#</span>
    <span class="c">#   n is a positive integer input variable set to the number</span>
    <span class="c">#     of columns of a.</span>
    <span class="c">#</span>
    <span class="c">#   a is an m by n array. on input a contains the matrix for</span>
    <span class="c">#     which the qr factorization is to be computed. on output</span>
    <span class="c">#     the strict upper trapezoidal part of a contains the strict</span>
    <span class="c">#     upper trapezoidal part of r, and the lower trapezoidal</span>
    <span class="c">#     part of a contains a factored form of q (the non-trivial</span>
    <span class="c">#     elements of the u vectors described above).</span>
    <span class="c">#</span>
    <span class="c">#   lda is a positive integer input variable not less than m</span>
    <span class="c">#     which specifies the leading dimension of the array a.</span>
    <span class="c">#</span>
    <span class="c">#   pivot is a logical input variable. if pivot is set true,</span>
    <span class="c">#     then column pivoting is enforced. if pivot is set false,</span>
    <span class="c">#     then no column pivoting is done.</span>
    <span class="c">#</span>
    <span class="c">#   ipvt is an integer output array of length lipvt. ipvt</span>
    <span class="c">#     defines the permutation matrix p such that a*p = q*r.</span>
    <span class="c">#     column j of p is column ipvt(j) of the identity matrix.</span>
    <span class="c">#     if pivot is false, ipvt is not referenced.</span>
    <span class="c">#</span>
    <span class="c">#   lipvt is a positive integer input variable. if pivot is false,</span>
    <span class="c">#     then lipvt may be as small as 1. if pivot is true, then</span>
    <span class="c">#     lipvt must be at least n.</span>
    <span class="c">#</span>
    <span class="c">#   rdiag is an output array of length n which contains the</span>
    <span class="c">#     diagonal elements of r.</span>
    <span class="c">#</span>
    <span class="c">#   acnorm is an output array of length n which contains the</span>
    <span class="c">#     norms of the corresponding columns of the input matrix a.</span>
    <span class="c">#     if this information is not needed, then acnorm can coincide</span>
    <span class="c">#     with rdiag.</span>
    <span class="c">#</span>
    <span class="c">#   wa is a work array of length n. if pivot is false, then wa</span>
    <span class="c">#     can coincide with rdiag.</span>
    <span class="c">#</span>
    <span class="c">#    subprograms called</span>
    <span class="c">#</span>
    <span class="c">#   minpack-supplied ... dpmpar,enorm</span>
    <span class="c">#</span>
    <span class="c">#   fortran-supplied ... dmax1,dsqrt,min0</span>
    <span class="c">#</span>
    <span class="c">#    argonne national laboratory. minpack project. march 1980.</span>
    <span class="c">#    burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
    <span class="c">#</span>
    <span class="c">#    **********</span>
    <span class="c">#</span>
    <span class="c"># PIVOTING / PERMUTING:</span>
    <span class="c">#</span>
    <span class="c"># Upon return, A(*,*) is in standard parameter order, A(*,IPVT) is in</span>
    <span class="c"># permuted order.</span>
    <span class="c">#</span>
    <span class="c"># RDIAG is in permuted order.</span>
    <span class="c"># ACNORM is in standard parameter order.</span>
    <span class="c">#</span>
    <span class="c">#</span>
    <span class="c"># NOTE: in IDL the factors appear slightly differently than described</span>
    <span class="c"># above.  The matrix A is still m x n where m &gt;= n.</span>
    <span class="c">#</span>
    <span class="c"># The &quot;upper&quot; triangular matrix R is actually stored in the strict</span>
    <span class="c"># lower left triangle of A under the standard notation of IDL.</span>
    <span class="c">#</span>
    <span class="c"># The reflectors that generate Q are in the upper trapezoid of A upon</span>
    <span class="c"># output.</span>
    <span class="c">#</span>
    <span class="c">#  EXAMPLE:  decompose the matrix [[9.,2.,6.],[4.,8.,7.]]</span>
    <span class="c">#   aa = [[9.,2.,6.],[4.,8.,7.]]</span>
    <span class="c">#   mpfit_qrfac, aa, aapvt, rdiag, aanorm</span>
    <span class="c">#    IDL&gt; print, aa</span>
    <span class="c">#         1.81818*   0.181818*   0.545455*</span>
    <span class="c">#        -8.54545+    1.90160*   0.432573*</span>
    <span class="c">#    IDL&gt; print, rdiag</span>
    <span class="c">#        -11.0000+   -7.48166+</span>
    <span class="c">#</span>
    <span class="c"># The components marked with a * are the components of the</span>
    <span class="c"># reflectors, and those marked with a + are components of R.</span>
    <span class="c">#</span>
    <span class="c"># To reconstruct Q and R we proceed as follows.  First R.</span>
    <span class="c">#   r = fltarr(m, n)</span>
    <span class="c"># for i = 0, n-1 do r(0:i,i) = aa(0:i,i)  # fill in lower diag</span>
    <span class="c">#   r(lindgen(n)*(m+1)) = rdiag</span>
    <span class="c">#</span>
    <span class="c"># Next, Q, which are composed from the reflectors.  Each reflector v</span>
    <span class="c"># is taken from the upper trapezoid of aa, and converted to a matrix</span>
    <span class="c"># via (I - 2 vT . v / (v . vT)).</span>
    <span class="c">#</span>
    <span class="c"># hh = ident                                  # identity matrix</span>
    <span class="c">#   for i = 0, n-1 do begin</span>
    <span class="c"># v = aa(*,i) &amp; if i GT 0 then v(0:i-1) = 0   # extract reflector</span>
    <span class="c"># hh = hh # (ident - 2*(v # v)/total(v * v))  # generate matrix</span>
    <span class="c">#   endfor</span>
    <span class="c">#</span>
    <span class="c"># Test the result:</span>
    <span class="c"># IDL&gt; print, hh # transpose(r)</span>
    <span class="c">#         9.00000     4.00000</span>
    <span class="c">#         2.00000     8.00000</span>
    <span class="c">#         6.00000     7.00000</span>
    <span class="c">#</span>
    <span class="c"># Note that it is usually never necessary to form the Q matrix</span>
    <span class="c"># explicitly, and MPFIT does not.</span></div>
<div class="viewcode-block" id="mpfit.qrfac"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.qrfac">[docs]</a>    <span class="k">def</span> <span class="nf">qrfac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">pivot</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering qrfac...&#39;</span><span class="p">)</span>
        <span class="n">machep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">machar</span><span class="o">.</span><span class="n">machep</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">sz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># Compute the initial column norms and initialize arrays</span>
        <span class="n">acnorm</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">acnorm</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])</span>
        <span class="n">rdiag</span> <span class="o">=</span> <span class="n">acnorm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">wa</span> <span class="o">=</span> <span class="n">rdiag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ipvt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c"># Reduce a to r with householder transformations</span>
        <span class="n">minmn</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">minmn</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pivot</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c"># Bring the column of largest norm into the pivot position</span>
                <span class="n">rmax</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rdiag</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>
                <span class="n">kmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">rdiag</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span> <span class="o">==</span> <span class="n">rmax</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ct</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kmax</span><span class="p">)</span>
                <span class="n">kmax</span> <span class="o">=</span> <span class="n">kmax</span> <span class="o">+</span> <span class="n">j</span>
                <span class="k">if</span> <span class="n">ct</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">kmax</span> <span class="o">=</span> <span class="n">kmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c"># Exchange rows via the pivot only.  Avoid actually exchanging</span>
                    <span class="c"># the rows, in case there is lots of memory transfer.  The</span>
                    <span class="c"># exchange occurs later, within the body of MPFIT, after the</span>
                    <span class="c"># extraneous columns of the matrix have been shed.</span>
                    <span class="k">if</span> <span class="n">kmax</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">temp</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">kmax</span><span class="p">]</span>
                        <span class="n">ipvt</span><span class="p">[</span><span class="n">kmax</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
                        <span class="n">rdiag</span><span class="p">[</span><span class="n">kmax</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdiag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">wa</span><span class="p">[</span><span class="n">kmax</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="c"># Compute the householder transformation to reduce the jth</span>
            <span class="c"># column of A to a multiple of the jth unit vector</span>
            <span class="n">lj</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ajj</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">:,</span> <span class="n">lj</span><span class="p">]</span>
            <span class="n">ajnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">ajj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ajnorm</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">lj</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ajnorm</span> <span class="o">=</span> <span class="o">-</span><span class="n">ajnorm</span>

            <span class="n">ajj</span> <span class="o">=</span> <span class="n">ajj</span> <span class="o">/</span> <span class="n">ajnorm</span>
            <span class="n">ajj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ajj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c"># *** Note optimization a(j:*,j)</span>
            <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">:,</span> <span class="n">lj</span><span class="p">]</span> <span class="o">=</span> <span class="n">ajj</span>

            <span class="c"># Apply the transformation to the remaining columns</span>
            <span class="c"># and update the norms</span>

            <span class="c"># NOTE to SELF: tried to optimize this by removing the loop,</span>
            <span class="c"># but it actually got slower.  Reverted to &quot;for&quot; loop to keep</span>
            <span class="c"># it simple.</span>
            <span class="k">if</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">lk</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">ajk</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">:,</span> <span class="n">lk</span><span class="p">]</span>
                    <span class="c"># *** Note optimization a(j:*,lk)</span>
                    <span class="c"># (corrected 20 Jul 2000)</span>
                    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">lj</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">:,</span> <span class="n">lk</span><span class="p">]</span> <span class="o">=</span> <span class="n">ajk</span> <span class="o">-</span> <span class="n">ajj</span> <span class="o">*</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ajk</span><span class="o">*</span><span class="n">ajj</span><span class="p">)</span><span class="o">/</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">lj</span><span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">pivot</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">rdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">lk</span><span class="p">]</span><span class="o">/</span><span class="n">rdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="n">rdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                                <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([(</span><span class="mf">1.</span><span class="o">-</span><span class="n">temp</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="mf">0.</span><span class="p">]))</span>
                            <span class="n">temp</span> <span class="o">=</span> <span class="n">rdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">wa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="k">if</span> <span class="p">(</span><span class="mf">0.05</span><span class="o">*</span><span class="n">temp</span><span class="o">*</span><span class="n">temp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">machep</span><span class="p">:</span>
                                <span class="n">rdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span> <span class="n">lk</span><span class="p">])</span>
                                <span class="n">wa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">rdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">rdiag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">ajnorm</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">rdiag</span><span class="p">,</span> <span class="n">acnorm</span><span class="p">]</span>

    <span class="c">#    Original FORTRAN documentation</span>
    <span class="c">#    **********</span>
    <span class="c">#</span>
    <span class="c">#    subroutine qrsolv</span>
    <span class="c">#</span>
    <span class="c">#    given an m by n matrix a, an n by n diagonal matrix d,</span>
    <span class="c">#    and an m-vector b, the problem is to determine an x which</span>
    <span class="c">#    solves the system</span>
    <span class="c">#</span>
    <span class="c">#          a*x = b ,     d*x = 0 ,</span>
    <span class="c">#</span>
    <span class="c">#    in the least squares sense.</span>
    <span class="c">#</span>
    <span class="c">#    this subroutine completes the solution of the problem</span>
    <span class="c">#    if it is provided with the necessary information from the</span>
    <span class="c">#    factorization, with column pivoting, of a. that is, if</span>
    <span class="c">#    a*p = q*r, where p is a permutation matrix, q has orthogonal</span>
    <span class="c">#    columns, and r is an upper triangular matrix with diagonal</span>
    <span class="c">#    elements of nonincreasing magnitude, then qrsolv expects</span>
    <span class="c">#    the full upper triangle of r, the permutation matrix p,</span>
    <span class="c">#    and the first n components of (q transpose)*b. the system</span>
    <span class="c">#    a*x = b, d*x = 0, is then equivalent to</span>
    <span class="c">#</span>
    <span class="c">#                 t    t</span>
    <span class="c">#          r*z = q *b ,  p *d*p*z = 0 ,</span>
    <span class="c">#</span>
    <span class="c">#    where x = p*z. if this system does not have full rank,</span>
    <span class="c">#    then a least squares solution is obtained. on output qrsolv</span>
    <span class="c">#    also provides an upper triangular matrix s such that</span>
    <span class="c">#</span>
    <span class="c">#           t   t              t</span>
    <span class="c">#          p *(a *a + d*d)*p = s *s .</span>
    <span class="c">#</span>
    <span class="c">#    s is computed within qrsolv and may be of separate interest.</span>
    <span class="c">#</span>
    <span class="c">#    the subroutine statement is</span>
    <span class="c">#</span>
    <span class="c">#      subroutine qrsolv(n,r,ldr,ipvt,diag,qtb,x,sdiag,wa)</span>
    <span class="c">#</span>
    <span class="c">#    where</span>
    <span class="c">#</span>
    <span class="c">#      n is a positive integer input variable set to the order of r.</span>
    <span class="c">#</span>
    <span class="c">#      r is an n by n array. on input the full upper triangle</span>
    <span class="c">#        must contain the full upper triangle of the matrix r.</span>
    <span class="c">#        on output the full upper triangle is unaltered, and the</span>
    <span class="c">#        strict lower triangle contains the strict upper triangle</span>
    <span class="c">#        (transposed) of the upper triangular matrix s.</span>
    <span class="c">#</span>
    <span class="c">#      ldr is a positive integer input variable not less than n</span>
    <span class="c">#        which specifies the leading dimension of the array r.</span>
    <span class="c">#</span>
    <span class="c">#      ipvt is an integer input array of length n which defines the</span>
    <span class="c">#        permutation matrix p such that a*p = q*r. column j of p</span>
    <span class="c">#        is column ipvt(j) of the identity matrix.</span>
    <span class="c">#</span>
    <span class="c">#      diag is an input array of length n which must contain the</span>
    <span class="c">#        diagonal elements of the matrix d.</span>
    <span class="c">#</span>
    <span class="c">#      qtb is an input array of length n which must contain the first</span>
    <span class="c">#        n elements of the vector (q transpose)*b.</span>
    <span class="c">#</span>
    <span class="c">#      x is an output array of length n which contains the least</span>
    <span class="c">#        squares solution of the system a*x = b, d*x = 0.</span>
    <span class="c">#</span>
    <span class="c">#      sdiag is an output array of length n which contains the</span>
    <span class="c">#        diagonal elements of the upper triangular matrix s.</span>
    <span class="c">#</span>
    <span class="c">#      wa is a work array of length n.</span>
    <span class="c">#</span>
    <span class="c">#    subprograms called</span>
    <span class="c">#</span>
    <span class="c">#      fortran-supplied ... dabs,dsqrt</span>
    <span class="c">#</span>
    <span class="c">#    argonne national laboratory. minpack project. march 1980.</span>
    <span class="c">#    burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
    <span class="c">#</span></div>
<div class="viewcode-block" id="mpfit.qrsolv"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.qrsolv">[docs]</a>    <span class="k">def</span> <span class="nf">qrsolv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">qtb</span><span class="p">,</span> <span class="n">sdiag</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering qrsolv...&#39;</span><span class="p">)</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span>
        <span class="c">#m = sz[0]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># copy r and (q transpose)*b to preserve input and initialize s.</span>
        <span class="c"># in particular, save the diagonal elements of r in x.</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">wa</span> <span class="o">=</span> <span class="n">qtb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c"># Eliminate the diagonal matrix d using a givens rotation</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">diag</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">sdiag</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sdiag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">diag</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

            <span class="c"># The transformations to eliminate the row of d modify only a</span>
            <span class="c"># single element of (q transpose)*b beyond the first n, which</span>
            <span class="c"># is initially zero.</span>

            <span class="n">qtbpj</span> <span class="o">=</span> <span class="mf">0.</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="n">cotan</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">sdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">sine</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">.</span><span class="mi">25</span> <span class="o">+</span> <span class="o">.</span><span class="mi">25</span><span class="o">*</span><span class="n">cotan</span><span class="o">*</span><span class="n">cotan</span><span class="p">)</span>
                    <span class="n">cosine</span> <span class="o">=</span> <span class="n">sine</span><span class="o">*</span><span class="n">cotan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tang</span> <span class="o">=</span> <span class="n">sdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                    <span class="n">cosine</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">.</span><span class="mi">25</span> <span class="o">+</span> <span class="o">.</span><span class="mi">25</span><span class="o">*</span><span class="n">tang</span><span class="o">*</span><span class="n">tang</span><span class="p">)</span>
                    <span class="n">sine</span> <span class="o">=</span> <span class="n">cosine</span><span class="o">*</span><span class="n">tang</span>

                <span class="c"># Compute the modified diagonal element of r and the</span>
                <span class="c"># modified element of ((q transpose)*b,0).</span>
                <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosine</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">sine</span><span class="o">*</span><span class="n">sdiag</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">cosine</span><span class="o">*</span><span class="n">wa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">sine</span><span class="o">*</span><span class="n">qtbpj</span>
                <span class="n">qtbpj</span> <span class="o">=</span> <span class="o">-</span><span class="n">sine</span><span class="o">*</span><span class="n">wa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">cosine</span><span class="o">*</span><span class="n">qtbpj</span>
                <span class="n">wa</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>

                <span class="c"># Accumulate the transformation in the row of s</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">cosine</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">sine</span><span class="o">*</span><span class="n">sdiag</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
                    <span class="n">sdiag</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">sine</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">cosine</span><span class="o">*</span><span class="n">sdiag</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
            <span class="n">sdiag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c"># Solve the triangular system for z.  If the system is singular</span>
        <span class="c"># then obtain a least squares solution</span>
        <span class="n">nsing</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">sdiag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nsing</span> <span class="o">=</span> <span class="n">wh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">wa</span><span class="p">[</span><span class="n">nsing</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">nsing</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">wa</span><span class="p">[</span><span class="n">nsing</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa</span><span class="p">[</span><span class="n">nsing</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">sdiag</span><span class="p">[</span><span class="n">nsing</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># Degenerate case</span>
            <span class="c"># *** Reverse loop ***</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsing</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">sum0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">nsing</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">wa</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">nsing</span><span class="p">])</span>
                <span class="n">wa</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wa</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="n">sum0</span><span class="p">)</span><span class="o">/</span><span class="n">sdiag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c"># Permute the components of z back to components of x</span>
        <span class="n">x</span><span class="p">[</span><span class="n">ipvt</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">sdiag</span><span class="p">)</span>

    <span class="c">#    Original FORTRAN documentation</span>
    <span class="c">#</span>
    <span class="c">#    subroutine lmpar</span>
    <span class="c">#</span>
    <span class="c">#    given an m by n matrix a, an n by n nonsingular diagonal</span>
    <span class="c">#    matrix d, an m-vector b, and a positive number delta,</span>
    <span class="c">#    the problem is to determine a value for the parameter</span>
    <span class="c">#    par such that if x solves the system</span>
    <span class="c">#</span>
    <span class="c">#       a*x = b ,    sqrt(par)*d*x = 0 ,</span>
    <span class="c">#</span>
    <span class="c">#    in the least squares sense, and dxnorm is the euclidean</span>
    <span class="c">#    norm of d*x, then either par is zero and</span>
    <span class="c">#</span>
    <span class="c">#       (dxnorm-delta) .le. 0.1*delta ,</span>
    <span class="c">#</span>
    <span class="c">#    or par is positive and</span>
    <span class="c">#</span>
    <span class="c">#       abs(dxnorm-delta) .le. 0.1*delta .</span>
    <span class="c">#</span>
    <span class="c">#    this subroutine completes the solution of the problem</span>
    <span class="c">#    if it is provided with the necessary information from the</span>
    <span class="c">#    qr factorization, with column pivoting, of a. that is, if</span>
    <span class="c">#    a*p = q*r, where p is a permutation matrix, q has orthogonal</span>
    <span class="c">#    columns, and r is an upper triangular matrix with diagonal</span>
    <span class="c">#    elements of nonincreasing magnitude, then lmpar expects</span>
    <span class="c">#    the full upper triangle of r, the permutation matrix p,</span>
    <span class="c">#    and the first n components of (q transpose)*b. on output</span>
    <span class="c">#    lmpar also provides an upper triangular matrix s such that</span>
    <span class="c">#</span>
    <span class="c">#        t   t                 t</span>
    <span class="c">#       p *(a *a + par*d*d)*p = s *s .</span>
    <span class="c">#</span>
    <span class="c">#    s is employed within lmpar and may be of separate interest.</span>
    <span class="c">#</span>
    <span class="c">#    only a few iterations are generally needed for convergence</span>
    <span class="c">#    of the algorithm. if, however, the limit of 10 iterations</span>
    <span class="c">#    is reached, then the output par will contain the best</span>
    <span class="c">#    value obtained so far.</span>
    <span class="c">#</span>
    <span class="c">#    the subroutine statement is</span>
    <span class="c">#</span>
    <span class="c">#   subroutine lmpar(n,r,ldr,ipvt,diag,qtb,delta,par,x,sdiag,</span>
    <span class="c">#                    wa1,wa2)</span>
    <span class="c">#</span>
    <span class="c">#    where</span>
    <span class="c">#</span>
    <span class="c">#   n is a positive integer input variable set to the order of r.</span>
    <span class="c">#</span>
    <span class="c">#   r is an n by n array. on input the full upper triangle</span>
    <span class="c">#     must contain the full upper triangle of the matrix r.</span>
    <span class="c">#     on output the full upper triangle is unaltered, and the</span>
    <span class="c">#     strict lower triangle contains the strict upper triangle</span>
    <span class="c">#     (transposed) of the upper triangular matrix s.</span>
    <span class="c">#</span>
    <span class="c">#   ldr is a positive integer input variable not less than n</span>
    <span class="c">#     which specifies the leading dimension of the array r.</span>
    <span class="c">#</span>
    <span class="c">#   ipvt is an integer input array of length n which defines the</span>
    <span class="c">#     permutation matrix p such that a*p = q*r. column j of p</span>
    <span class="c">#     is column ipvt(j) of the identity matrix.</span>
    <span class="c">#</span>
    <span class="c">#   diag is an input array of length n which must contain the</span>
    <span class="c">#     diagonal elements of the matrix d.</span>
    <span class="c">#</span>
    <span class="c">#   qtb is an input array of length n which must contain the first</span>
    <span class="c">#     n elements of the vector (q transpose)*b.</span>
    <span class="c">#</span>
    <span class="c">#   delta is a positive input variable which specifies an upper</span>
    <span class="c">#     bound on the euclidean norm of d*x.</span>
    <span class="c">#</span>
    <span class="c">#   par is a nonnegative variable. on input par contains an</span>
    <span class="c">#     initial estimate of the levenberg-marquardt parameter.</span>
    <span class="c">#     on output par contains the final estimate.</span>
    <span class="c">#</span>
    <span class="c">#   x is an output array of length n which contains the least</span>
    <span class="c">#     squares solution of the system a*x = b, sqrt(par)*d*x = 0,</span>
    <span class="c">#     for the output par.</span>
    <span class="c">#</span>
    <span class="c">#   sdiag is an output array of length n which contains the</span>
    <span class="c">#     diagonal elements of the upper triangular matrix s.</span>
    <span class="c">#</span>
    <span class="c">#   wa1 and wa2 are work arrays of length n.</span>
    <span class="c">#</span>
    <span class="c">#    subprograms called</span>
    <span class="c">#</span>
    <span class="c">#   minpack-supplied ... dpmpar,enorm,qrsolv</span>
    <span class="c">#</span>
    <span class="c">#   fortran-supplied ... dabs,dmax1,dmin1,dsqrt</span>
    <span class="c">#</span>
    <span class="c">#    argonne national laboratory. minpack project. march 1980.</span>
    <span class="c">#    burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
    <span class="c">#</span></div>
<div class="viewcode-block" id="mpfit.lmpar"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.lmpar">[docs]</a>    <span class="k">def</span> <span class="nf">lmpar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">diag</span><span class="p">,</span> <span class="n">qtb</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">sdiag</span><span class="p">,</span> <span class="n">par</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering lmpar...&#39;</span><span class="p">)</span>
        <span class="n">dwarf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">machar</span><span class="o">.</span><span class="n">minnum</span>
        <span class="n">machep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">machar</span><span class="o">.</span><span class="n">machep</span>
        <span class="n">sz</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span>
        <span class="c">#m = sz[0]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">sz</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># Compute and store in x the gauss-newton direction.  If the</span>
        <span class="c"># jacobian is rank-deficient, obtain a least-squares solution</span>
        <span class="n">nsing</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">wa1</span> <span class="o">=</span> <span class="n">qtb</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">rthresh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">)))</span> <span class="o">*</span> <span class="n">machep</span>
        <span class="n">wh</span> <span class="o">=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">rthresh</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nsing</span> <span class="o">=</span> <span class="n">wh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">wa1</span><span class="p">[</span><span class="n">wh</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">nsing</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># *** Reverse loop ***</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsing</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">wa1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c"># Note: ipvt here is a permutation array</span>
        <span class="n">x</span><span class="p">[</span><span class="n">ipvt</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa1</span>

        <span class="c"># Initialize the iteration counter.  Evaluate the function at the</span>
        <span class="c"># origin, and test for acceptance of the gauss-newton direction</span>
        <span class="nb">iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">wa2</span> <span class="o">=</span> <span class="n">diag</span> <span class="o">*</span> <span class="n">x</span>
        <span class="n">dxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa2</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">dxnorm</span> <span class="o">-</span> <span class="n">delta</span>
        <span class="k">if</span> <span class="n">fp</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">delta</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">sdiag</span><span class="p">]</span>

        <span class="c"># If the jacobian is not rank deficient, the newton step provides a</span>
        <span class="c"># lower bound, parl, for the zero of the function.  Otherwise set</span>
        <span class="c"># this bound to zero.</span>

        <span class="n">parl</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="n">nsing</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">wa1</span> <span class="o">=</span> <span class="n">diag</span><span class="p">[</span><span class="n">ipvt</span><span class="p">]</span> <span class="o">*</span> <span class="n">wa2</span><span class="p">[</span><span class="n">ipvt</span><span class="p">]</span> <span class="o">/</span> <span class="n">dxnorm</span>
            <span class="n">wa1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c"># Degenerate case</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>   <span class="c"># Note &quot;1&quot; here, not zero</span>
                <span class="n">sum0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">wa1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>
                <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum0</span><span class="p">)</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa1</span><span class="p">)</span>
            <span class="n">parl</span> <span class="o">=</span> <span class="p">((</span><span class="n">fp</span><span class="o">/</span><span class="n">delta</span><span class="p">)</span><span class="o">/</span><span class="n">temp</span><span class="p">)</span><span class="o">/</span><span class="n">temp</span>

        <span class="c"># Calculate an upper bound, paru, for the zero of the function</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">sum0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">qtb</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum0</span><span class="o">/</span><span class="n">diag</span><span class="p">[</span><span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
        <span class="n">gnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa1</span><span class="p">)</span>
        <span class="n">paru</span> <span class="o">=</span> <span class="n">gnorm</span><span class="o">/</span><span class="n">delta</span>
        <span class="k">if</span> <span class="n">paru</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">paru</span> <span class="o">=</span> <span class="n">dwarf</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">delta</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">])</span>

        <span class="c"># If the input par lies outside of the interval (parl,paru), set</span>
        <span class="c"># par to the closer endpoint</span>

        <span class="n">par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">par</span><span class="p">,</span> <span class="n">parl</span><span class="p">])</span>
        <span class="n">par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">par</span><span class="p">,</span> <span class="n">paru</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">par</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">par</span> <span class="o">=</span> <span class="n">gnorm</span><span class="o">/</span><span class="n">dxnorm</span>

        <span class="c"># Beginning of an interation</span>
        <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
            <span class="nb">iter</span> <span class="o">=</span> <span class="nb">iter</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c"># Evaluate the function at the current value of par</span>
            <span class="k">if</span> <span class="n">par</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">dwarf</span><span class="p">,</span> <span class="n">paru</span><span class="o">*</span><span class="mf">0.001</span><span class="p">])</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
            <span class="n">wa1</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">diag</span>
            <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">sdiag</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qrsolv</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">wa1</span><span class="p">,</span> <span class="n">qtb</span><span class="p">,</span> <span class="n">sdiag</span><span class="p">)</span>
            <span class="n">wa2</span> <span class="o">=</span> <span class="n">diag</span><span class="o">*</span><span class="n">x</span>
            <span class="n">dxnorm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa2</span><span class="p">)</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">fp</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">dxnorm</span> <span class="o">-</span> <span class="n">delta</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">delta</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="p">((</span><span class="n">parl</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">fp</span> <span class="o">&lt;=</span> <span class="n">temp</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">temp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="nb">iter</span> <span class="o">==</span> <span class="mi">10</span><span class="p">):</span>
                <span class="k">break</span>

            <span class="c"># Compute the newton correction</span>
            <span class="n">wa1</span> <span class="o">=</span> <span class="n">diag</span><span class="p">[</span><span class="n">ipvt</span><span class="p">]</span> <span class="o">*</span> <span class="n">wa2</span><span class="p">[</span><span class="n">ipvt</span><span class="p">]</span> <span class="o">/</span> <span class="n">dxnorm</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">sdiag</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">wa1</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">wa1</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa1</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">sdiag</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># Degenerate case</span>

            <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">enorm</span><span class="p">(</span><span class="n">wa1</span><span class="p">)</span>
            <span class="n">parc</span> <span class="o">=</span> <span class="p">((</span><span class="n">fp</span><span class="o">/</span><span class="n">delta</span><span class="p">)</span><span class="o">/</span><span class="n">temp</span><span class="p">)</span><span class="o">/</span><span class="n">temp</span>

            <span class="c"># Depending on the sign of the function, update parl or paru</span>
            <span class="k">if</span> <span class="n">fp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">parl</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">parl</span><span class="p">,</span> <span class="n">par</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">fp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">paru</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">paru</span><span class="p">,</span> <span class="n">par</span><span class="p">])</span>

            <span class="c"># Compute an improved estimate for par</span>
            <span class="n">par</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">parl</span><span class="p">,</span> <span class="n">par</span><span class="o">+</span><span class="n">parc</span><span class="p">])</span>

            <span class="c"># End of an iteration</span>

        <span class="c"># Termination</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">par</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">sdiag</span><span class="p">]</span>

    <span class="c"># Procedure to tie one parameter to another.</span></div>
<div class="viewcode-block" id="mpfit.tie"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.tie">[docs]</a>    <span class="k">def</span> <span class="nf">tie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">ptied</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering tie...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ptied</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ptied</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ptied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">cmd</span> <span class="o">=</span> <span class="s">&#39;p[&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;] = &#39;</span> <span class="o">+</span> <span class="n">ptied</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">exec</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="c">#    Original FORTRAN documentation</span>
    <span class="c">#    **********</span>
    <span class="c">#</span>
    <span class="c">#    subroutine covar</span>
    <span class="c">#</span>
    <span class="c">#    given an m by n matrix a, the problem is to determine</span>
    <span class="c">#    the covariance matrix corresponding to a, defined as</span>
    <span class="c">#</span>
    <span class="c">#                   t</span>
    <span class="c">#          inverse(a *a) .</span>
    <span class="c">#</span>
    <span class="c">#    this subroutine completes the solution of the problem</span>
    <span class="c">#    if it is provided with the necessary information from the</span>
    <span class="c">#    qr factorization, with column pivoting, of a. that is, if</span>
    <span class="c">#    a*p = q*r, where p is a permutation matrix, q has orthogonal</span>
    <span class="c">#    columns, and r is an upper triangular matrix with diagonal</span>
    <span class="c">#    elements of nonincreasing magnitude, then covar expects</span>
    <span class="c">#    the full upper triangle of r and the permutation matrix p.</span>
    <span class="c">#    the covariance matrix is then computed as</span>
    <span class="c">#</span>
    <span class="c">#                     t  t</span>
    <span class="c">#          p*inverse(r *r)*p  .</span>
    <span class="c">#</span>
    <span class="c">#    if a is nearly rank deficient, it may be desirable to compute</span>
    <span class="c">#    the covariance matrix corresponding to the linearly independent</span>
    <span class="c">#    columns of a. to define the numerical rank of a, covar uses</span>
    <span class="c">#    the tolerance tol. if l is the largest integer such that</span>
    <span class="c">#</span>
    <span class="c">#          abs(r(l,l)) .gt. tol*abs(r(1,1)) ,</span>
    <span class="c">#</span>
    <span class="c">#    then covar computes the covariance matrix corresponding to</span>
    <span class="c">#    the first l columns of r. for k greater than l, column</span>
    <span class="c">#    and row ipvt(k) of the covariance matrix are set to zero.</span>
    <span class="c">#</span>
    <span class="c">#    the subroutine statement is</span>
    <span class="c">#</span>
    <span class="c">#      subroutine covar(n,r,ldr,ipvt,tol,wa)</span>
    <span class="c">#</span>
    <span class="c">#    where</span>
    <span class="c">#</span>
    <span class="c">#      n is a positive integer input variable set to the order of r.</span>
    <span class="c">#</span>
    <span class="c">#      r is an n by n array. on input the full upper triangle must</span>
    <span class="c">#        contain the full upper triangle of the matrix r. on output</span>
    <span class="c">#        r contains the square symmetric covariance matrix.</span>
    <span class="c">#</span>
    <span class="c">#      ldr is a positive integer input variable not less than n</span>
    <span class="c">#        which specifies the leading dimension of the array r.</span>
    <span class="c">#</span>
    <span class="c">#      ipvt is an integer input array of length n which defines the</span>
    <span class="c">#        permutation matrix p such that a*p = q*r. column j of p</span>
    <span class="c">#        is column ipvt(j) of the identity matrix.</span>
    <span class="c">#</span>
    <span class="c">#      tol is a nonnegative input variable used to define the</span>
    <span class="c">#        numerical rank of a in the manner described above.</span>
    <span class="c">#</span>
    <span class="c">#      wa is a work array of length n.</span>
    <span class="c">#</span>
    <span class="c">#    subprograms called</span>
    <span class="c">#</span>
    <span class="c">#      fortran-supplied ... dabs</span>
    <span class="c">#</span>
    <span class="c">#    argonne national laboratory. minpack project. august 1980.</span>
    <span class="c">#    burton s. garbow, kenneth e. hillstrom, jorge j. more</span>
    <span class="c">#</span>
    <span class="c">#    **********</span></div>
<div class="viewcode-block" id="mpfit.calc_covar"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.mpfit.calc_covar">[docs]</a>    <span class="k">def</span> <span class="nf">calc_covar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rr</span><span class="p">,</span> <span class="n">ipvt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1.e-14</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;Entering calc_covar...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">rank</span><span class="p">(</span><span class="n">rr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;ERROR: r must be a two-dimensional matrix&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">print</span> <span class="p">(</span><span class="s">&#39;ERROR: r must be a square matrix&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">ipvt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ipvt</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">rr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>

        <span class="c"># For the inverse of r in the full upper triangle of r</span>
        <span class="n">l</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">tolr</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">tolr</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">temp</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">k</span>

        <span class="c"># Form the full upper triangle of the inverse of (r transpose)*r</span>
        <span class="c"># in the full upper triangle of r</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                    <span class="n">temp</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                    <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">temp</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">temp</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>

        <span class="c"># For the full lower triangle of the covariance matrix</span>
        <span class="c"># in the strict lower triangle or and in wa</span>
        <span class="n">wa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">jj</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">sing</span> <span class="o">=</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">l</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sing</span><span class="p">:</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">ii</span> <span class="o">=</span> <span class="n">ipvt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">&gt;</span> <span class="n">jj</span><span class="p">:</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ii</span> <span class="o">&lt;</span> <span class="n">jj</span><span class="p">:</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">jj</span><span class="p">,</span> <span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">wa</span><span class="p">[</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

        <span class="c"># Symmetrize the covariance matrix in r</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">r</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">wa</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">r</span>

</div></div>
<div class="viewcode-block" id="machar"><a class="viewcode-back" href="../../../../resolvedstellarpops.math.mpfit.html#resolvedstellarpops.math.mpfit.mpfit.machar">[docs]</a><span class="k">class</span> <span class="nc">machar</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">double</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">double</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">machep</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxnum</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minnum</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">tiny</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxlog</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxnum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minlog</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minnum</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rdwarf</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minnum</span><span class="o">*</span><span class="mf">1.5</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rgiant</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxnum</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span></div>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Phil Rosesenfield.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>